(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{416:function(e,a,n){"use strict";n.r(a);var t=n(43),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"new-object"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-object"}},[e._v("#")]),e._v(" new Object()")]),e._v(" "),n("p",[e._v("直接通过构造函数创建一个新对象。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var obj = new Object()\n//等同于 var obj = {}\n")])])]),n("p",[e._v("使用字面量的方式更简单，其实他俩是一样的。\n优点是足够简单，缺点是每个对象都是独立的。")]),e._v(" "),n("h2",{attrs:{id:"工厂模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[e._v("#")]),e._v(" 工厂模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function createObj(name,age){\n    var obj = {};\n    obj.name=name;\n    obj.age=age;\n    return obj\n}\nvar Anson = createObj('Anson', 18)\nconsole.log(Anson)\n//{name: \"Anson\", age: 18}\n")])])]),n("p",[e._v("优点是 可以解决创建多个相似对象的问题，缺点是 无法识别对象的类型。")]),e._v(" "),n("h2",{attrs:{id:"构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[e._v("#")]),e._v(" 构造函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(name,age){\n    this.name =name;\n    this.age=age;\n    this.sayName =function (){ alert(this.name) }\n}\nvar person = new Person('小明',13);\nconsole.log(person);\n//Person {name: \"小明\", age: 13, sayName: ƒ}\n")])])]),n("p",[e._v("优点是 可以创建特定类型的对象，缺点是 多个实例重复创建方法")]),e._v(" "),n("h2",{attrs:{id:"（构造函数-原型）组合模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#（构造函数-原型）组合模式"}},[e._v("#")]),e._v(" （构造函数+原型）组合模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(name, age){\n    this.name = name;\n    this.age = age;\n    Person.prototype.sayName = function (){ alert(this.name) }\n }\nvar person = new Person('小白',18)\nconsole.log(person);\n//Person {name: \"小白\", age: 18} __proto__ -> sayName: ƒ ()\n")])])]),n("p",[e._v("优点 多个实例引用一个原型上的方法 比较常用")]),e._v(" "),n("h2",{attrs:{id:"动态原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态原型"}},[e._v("#")]),e._v(" 动态原型")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(name,age){\n    this.name=name\n    this.age =age\n    if(typeof this.sayName != 'function'){\n        Person.prototype.sayName = function(){ alert(this.name) }\n  }\n}\nvar person = new Person('小红',15)\nconsole.log(person);\n//Person {name: \"小红\", age: 15} 动态创建sayName: ƒ ()\n")])])]),n("p",[e._v("优点 可以判断某个方法是否有效，来决定是否需要初始化原型，if只会在仅在碰到第一个实例调用方法\n时会执行，此后所有实例共享此方法，需要注意的一点是，不能重新原型对象。")]),e._v(" "),n("h2",{attrs:{id:"寄生构造函数模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#寄生构造函数模式"}},[e._v("#")]),e._v(" 寄生构造函数模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function Person(name,age,job){\n    var o=new Object();\n    o.name=name;\n    o.age=age;\n    o.job=job;\n    o.sayName=function(){\n        console.log(this.name)\n    }\n    return o;\n}\nvar friend=new Person("her",18,"Front-end Engineer");\nfriend.sayName();\n//her\n')])])]),n("p",[e._v("除了使用"),n("code",[e._v("new")]),e._v("操作符，其他的和工厂函数一样，可以为对象创建构造函数。")]),e._v(" "),n("h2",{attrs:{id:"稳妥模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#稳妥模式"}},[e._v("#")]),e._v(" 稳妥模式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Person(name, age){\n    var o={};\n    o.sayName=function(){ alert(name) }\n    return o;\n}\nvar person = ('小亮'，24);\nperson.sayName();//’小亮‘\n")])])]),n("p",[e._v("除了使用"),n("code",[e._v("person.sayName()")]),e._v("之外 ，没有办法在访问到name的值，适合在某些安全执行环景下使用。")]),e._v(" "),n("h2",{attrs:{id:"object-create"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-create"}},[e._v("#")]),e._v(" Object.create()")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const person = {\n  isHuman: false,\n  printIntroduction: function () {\n    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);\n  }\n};\n\nconst me = Object.create(person);\n\nme.name = "Matthew"; // "name" is a property set on "me", but not on "person"\nme.isHuman = true; // inherited properties can be overwritten\n\nme.printIntroduction();\n// expected output: "My name is Matthew. Am I human? true"\n')])])]),n("p",[e._v("传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的__proto__，实现继承。")]),e._v(" "),n("p",[n("strong",[e._v("参考：")]),e._v("《JavaScript高级程序设计第三版》、"),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),n("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);