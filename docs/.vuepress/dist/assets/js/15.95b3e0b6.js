(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{424:function(a,t,e){"use strict";e.r(t);var n=e(43),s=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("call() 参考：https://blog.csdn.net/ywl570717586/article/details/52681392/\nthis解读参考：https://juejin.im/post/5b3715def265da59af40a630\n函数传入值参考：js高程 p113")]),a._v(" "),e("h3",{attrs:{id:"快速删除尾部数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速删除尾部数组"}},[a._v("#")]),a._v(" 快速删除尾部数组")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var arr=[1,2,3,4,5];\narr.length=3;\nconsole.log(arr)//[1,2,3]\n")])])]),e("p",[a._v("直接改变数组的length的值")]),a._v(" "),e("h3",{attrs:{id:"从数组中移除重复元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从数组中移除重复元素"}},[a._v("#")]),a._v(" 从数组中移除重复元素")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var arr = [1,1,2,2,3,3]\nconst removeDuplicateltems = arr => [...new Set(arr)];\nconsole.log(removeDuplicateltems(arr))//[1,2,3]\n\t\n")])])]),e("h3",{attrs:{id:"函数作为值传入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数作为值传入"}},[a._v("#")]),a._v(" 函数作为值传入")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//把函数作为值传入进去\n    function callSomeFunction(someFunction,someArgument){\n      return someFunction(someArgument);\n    }\n")])])]),e("p",[a._v("最终调用的这个函数 他有两个参数， 第一个参数是一个方法 ， 第二个参数是第一个方法的参数。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    function add10(num){\n      return num + 10;\n    }\n    var result1=callSomeFunction(add10,10);\n      console.log(result1);//20\n")])])]),e("p",[a._v("这个例子稍微一看就明白了吧，  传入的10 最终成了add()的参数, 也就是成了num,  所以结果是20")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('    function getGreeting(name){\n      return "holle," + name;\n    }\n    var result2=callSomeFunction(getGreeting, "Nicholas");\n    console.log(result2);//holle Nicholas\n')])])]),e("p",[a._v("上面的理解了  这个也就不难了  同理 “ Nicholas” 变成了getGreeting() 的参数 name，所以输出结果是 holle Nicholas")]),a._v(" "),e("h3",{attrs:{id:"call-解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-解释"}},[a._v("#")]),a._v(" call() 解释")]),a._v(" "),e("p",[a._v("先看看关于call()的官方解释，“调用一个对象的一个方法，以另一个对象替换当前对象。”，看了这样的解释，或许让你更摸不着头脑了。看例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var x = "我是全局变量";　　　　//定义全局变量x\nfunction a(){　　　　　　　　　//定义函数类结构a　　\n    this.x = "我是在函数类结构a中声明的哦";    \n}\n//定义普通函数，弹出当前指针所包含的变量x的值\nfunction f(){       \n    alert (this.x);\n}\nf.call(new a());//返回值为“我是在函数类结构a中声明的哦”\n')])])]),e("p",[a._v("我的理解是，f.call(new a())就是把函数（其实也是对象）f复制到被调用对象“new a()”下面去解析，事实上和下面这段代码的解析结果一样：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function a(){\n　　this.x = "我是在函数类结构a中声明的哦";\n　　alert(this.x);    //我是在函数类结构a中声明的哦\n}\na();\n')])])]),e("p",[a._v("只不过此时变量X的作用域不同而已，咿…看起来好像有点继承的味道哦，难道不是吗？在上例中,f完全被构造函数a的实力对象继承了，如果说这还不足以说明a.call(b)是一种继承模式，那么再看一个更具有继承味道的用法吧。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function f(){    \n    this.a ="a";    \n    this.b = function(){    \n        alert("b");\n    }\n}\nfunction e(){    \n    f.call(this);     \n}\nvar c = new e();\nalert(c.a);  //弹出a\nc.b();    //弹出b\n')])])]),e("p",[a._v("在这个例子中，只要会使用浏览器的朋友，都能看得出来e完全继承了f的属性和方法，否则是无法解释的，因为在e中并没有定义属性a和b，那么按常理推断在e的实例对象c中，并不会出现这两个属性。")])])}),[],!1,null,null,null);t.default=s.exports}}]);