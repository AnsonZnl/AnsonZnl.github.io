(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{362:function(e,n,t){"use strict";t.r(n);var a=t(43),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("strong",[e._v("可以说是我目前看到最详细的 webpack 4 入门文章。\n基本看完这个，基本也算一个合格的初级webpack配置工程师了。")])]),e._v(" "),t("blockquote",[t("p",[e._v("webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新一下，方便大家用起 webpack 4。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/7072486-30b8f96f6314cf58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"webpack"}})]),e._v(" "),t("h2",{attrs:{id:"写在开头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在开头"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("写在开头")]),e._v(" "),t("p",[t("s",[e._v("先说说为什么要写这篇文章，最初的原因是组里的小朋友们看了 "),t("a",{attrs:{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack"),t("OutboundLink")],1),e._v(" 文档后，表情都是这样的：摘自 webpack 一篇文档的评论区）")])]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/7072486-7cc744905b9edb5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"wtf"}})]),e._v(" "),t("p",[t("s",[e._v("是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。")])]),e._v(" "),t("p",[e._v("官网新的 "),t("a",{attrs:{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack"),t("OutboundLink")],1),e._v(" 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。")]),e._v(" "),t("p",[e._v("可能会有人问 webpack 到底有什么用，你不能上来就糊我一脸代码让我马上搞，我照着搞了一遍结果根本没什么用，都是骗人的。所以，在说 webpack 之前，我想先谈一下前端打包方案这几年的演进历程，在什么场景下，我们遇到了什么问题，催生出了应对这些问题的工具。了解了需求和目的之后，你就知道什么时候 webpack 可以帮到你。我希望我用完之后很爽，你们用完之后也是。")]),e._v(" "),t("h2",{attrs:{id:"先说说前端打包方案的黑暗历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先说说前端打包方案的黑暗历史"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%85%88%E8%AF%B4%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88%E7%9A%84%E9%BB%91%E6%9A%97%E5%8E%86%E5%8F%B2",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("先说说前端打包方案的黑暗历史")]),e._v(" "),t("p",[e._v("在很长的一段前端历史里，是不存在打包这个说法的。那个时候页面基本是纯静态的或者服务端输出的，没有 AJAX，也没有 jQuery。那个时候的 JavaScript 就像个玩具，用处大概就是在侧栏弄个时钟，用 media player 放个 mp3 之类的脚本，代码量不是很多，直接放在 "),t("code",[e._v("<script>")]),e._v(" 标签里或者弄个 js 文件引一下就行，日子过得很轻松愉快。")]),e._v(" "),t("p",[e._v("随后的几年，人们开始尝试在一个页面里做更多的事情。容器的显示，隐藏，切换。用 css 写的弹层，图片轮播等等。但如果一个页面内不能向服务器请求数据，能做的事情毕竟有限的，代码的量也能维持在页面交互逻辑范围内。这时候很多人开始突破一个页面能做的事情的范围，使用隐藏的 iframe 和 flash 等作为和服务器通信的桥梁，新世界的大门慢慢地被打开，在一个页面内和服务器进行数据交互，意味着以前需要跳转多个页面的事情现在可以用一个页面搞定。但由于 iframe 和 flash 技术过于 tricky 和复杂，并没能得到广泛的推广。")]),e._v(" "),t("p",[e._v("直到 Google 推出 Gmail 的时候（2004 年），人们意识到了一个被忽略的接口，"),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",target:"_blank",rel:"noopener noreferrer"}},[e._v("XMLHttpRequest"),t("OutboundLink")],1),e._v(", 也就是我们俗称的 AJAX, 这是一个使用方便的，兼容性良好的服务器通信接口。从此开始，我们的页面开始玩出各种花来了，前端一下子出现了各种各样的库，"),t("a",{attrs:{href:"http://prototypejs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Prototype"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://dojotoolkit.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dojo"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"http://mootools.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("MooTools"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://www.sencha.com/products/extjs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ext JS"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://jquery.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("jQuery"),t("OutboundLink")],1),e._v("…… 我们开始往页面里插入各种库和插件，我们的 js 文件也就爆炸了。")]),e._v(" "),t("p",[e._v("随着 js 能做的事情越来越多，引用越来越多，文件越来越大，加上当时大约只有 2Mbps 左右的网速，下载速度还不如 3G 网络，对 js 文件的压缩和合并的需求越来越强烈，当然这里面也有把代码混淆了不容易被盗用等其他因素在里面。"),t("a",{attrs:{href:"http://crockford.com/javascript/jsmin",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSMin"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"http://yui.github.io/yuicompressor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("YUI Compressor"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://developers.google.com/closure/compiler/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Closure Compiler"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"http://lisperator.net/uglifyjs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("UglifyJS"),t("OutboundLink")],1),e._v(" 等 js 文件压缩合并工具陆陆续续诞生了。压缩工具是有了，但我们得要执行它，最简单的办法呢，就是 windows 上搞个 bat 脚本，mac / linux 上搞个 bash 脚本，哪几个文件要合并在一块的，哪几个要压缩的，发布的时候运行一下脚本，生成压缩后的文件。")]),e._v(" "),t("p",[e._v("基于合并压缩技术，项目越做越大，问题也越来越多，大概就是以下这些问题：")]),e._v(" "),t("ul",[t("li",[e._v("库和插件为了要给他人调用，肯定要找个地方注册，一般就是在 window 下申明一个全局的函数或对象。难保哪天用的两个库在全局用同样的名字，那就冲突了。")]),e._v(" "),t("li",[e._v("库和插件如果还依赖其他的库和插件，就要告知使用人，需要先引哪些依赖库，那些依赖库也有自己的依赖库的话，就要先引依赖库的依赖库，以此类推。")])]),e._v(" "),t("p",[e._v("恰好就在这个时候（2009 年），随着后端 JavaScript 技术的发展，人们提出了 "),t("a",{attrs:{href:"http://wiki.commonjs.org/wiki/Modules/1.1.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("CommonJS"),t("OutboundLink")],1),e._v(" 的模块化规范，大概的语法是： 如果 "),t("code",[e._v("a.js")]),e._v(" 依赖 "),t("code",[e._v("b.js")]),e._v(" 和 "),t("code",[e._v("c.js")]),e._v("， 那么就在 "),t("code",[e._v("a.js")]),e._v(" 的头部，引入这些依赖文件：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var b = require('./b')\nvar c = require('./c')\n")])])]),t("p",[e._v("那么变量 "),t("code",[e._v("b")]),e._v(" 和 "),t("code",[e._v("c")]),e._v(" 会是什么呢？那就是 b.js 和 c.js 导出的东西，比如 b.js 可以这样导出：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("exports.square = function(num) {\n  return num * num\n}\n")])])]),t("p",[e._v("然后就可以在 a.js 使用这个 "),t("code",[e._v("square")]),e._v(" 方法：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var n = b.square(2)\n")])])]),t("p",[e._v("如果 c.js 依赖 d.js， 导出的是一个 "),t("code",[e._v("Number")]),e._v("， 那么可以这样写：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var d = require('./d')\nmodule.exports = d.PI // 假设 d.PI 的值是 3.14159\n")])])]),t("p",[e._v("那么 a.js 中的变量 "),t("code",[e._v("c")]),e._v(" 就是数字 "),t("code",[e._v("3.14159")]),e._v("，具体的语法规范可以查看 Node.js 的 "),t("a",{attrs:{href:"https://nodejs.org/api/modules.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("但是 CommonJS 在浏览器内并不适用。因为 "),t("code",[e._v("require()")]),e._v(" 的返回是同步的，意味着有多个依赖的话需要一个一个依次下载，堵塞了 js 脚本的执行。所以人们就在 CommonJS 的基础上定义了 "),t("a",{attrs:{href:"https://github.com/amdjs/amdjs-api",target:"_blank",rel:"noopener noreferrer"}},[e._v("Asynchronous Module Definition (AMD)"),t("OutboundLink")],1),e._v(" 规范(2011 年），使用了异步回调的语法来并行下载多个依赖项，比如作为入口的 a.js 可以这样写：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("require(['./b', './c'], function(b, c) {\n  var n = b.square(2)\n  console.log(c)\n})\n")])])]),t("p",[e._v("相应的导出语法也是异步回调方式，比如 "),t("code",[e._v("c.js")]),e._v(" 依赖 "),t("code",[e._v("d.js")]),e._v("， 就写成这样：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("define(['./d'], function(d) {\n  return d.PI\n})\n")])])]),t("p",[e._v("可以看到，定义一个模块是使用 "),t("code",[e._v("define()")]),e._v(" 函数，"),t("code",[e._v("define()")]),e._v(" 和 "),t("code",[e._v("require()")]),e._v(" 的区别是，"),t("code",[e._v("define()")]),e._v(" 必须要在回调函数中返回一个值作为导出的东西，"),t("code",[e._v("require()")]),e._v(" 不需要导出东西，因此回调函数中不需要返回值，也无法作为被依赖项被其他文件导入，因此一般用于入口文件，比如页面中这样加载 "),t("code",[e._v("a.js")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-text-html-basic extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<script src="js/require.js" data-main="js/a"><\/script>\n')])])]),t("p",[e._v("以上是 AMD 规范的基本用法，更详细的就不多说了（反正也淘汰了～），有兴趣的可以看 "),t("a",{attrs:{href:"http://requirejs.org/docs/api.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("js 模块化问题基本解决了，css 和 html 也没闲着。什么 "),t("a",{attrs:{href:"http://lesscss.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("less"),t("OutboundLink")],1),e._v("，"),t("a",{attrs:{href:"http://sass-lang.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sass"),t("OutboundLink")],1),e._v("，"),t("a",{attrs:{href:"http://stylus-lang.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("stylus"),t("OutboundLink")],1),e._v(" 的 css 预处理器横空出世，说能帮我们简化 css 的写法，自动给你加 vendor prefix。html 在这期间也出现了一堆模板语言，什么 "),t("a",{attrs:{href:"http://handlebarsjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("handlebars"),t("OutboundLink")],1),e._v("，"),t("a",{attrs:{href:"http://www.embeddedjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ejs"),t("OutboundLink")],1),e._v("，"),t("a",{attrs:{href:"http://jade-lang.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("jade"),t("OutboundLink")],1),e._v("，可以把 ajax 拿到的数据插入到模板中，然后用 innerHTML 显示到页面上。")]),e._v(" "),t("p",[e._v("托 AMD 和 CSS 预处理和模板语言的福，我们的编译脚本也洋洋洒洒写了百来行。命令行脚本有个不好的地方，就是 windows 和 mac/linux 是不通用的，如果有跨平台需求的话，windows 要装个可以执行 bash 脚本的命令行工具，比如 msys（目前最新的是 "),t("a",{attrs:{href:"http://msys2.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("msys2"),t("OutboundLink")],1),e._v("），或者使用 php 或 python 等其他语言的脚本来编写，对于非全栈型的前端程序员来说，写 bash / php / python 还是很生涩的。因此我们需要一个简单的打包工具，可以利用各种编译工具，编译 / 压缩 js、css、html、图片等资源。然后 "),t("a",{attrs:{href:"http://gruntjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Grunt"),t("OutboundLink")],1),e._v(" 产生了（2012 年），配置文件格式是我们最爱的 js，写法也很简单，社区有非常多的插件支持各种编译、lint、测试工具。一年多后另一个打包工具 "),t("a",{attrs:{href:"http://gulpjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gulp"),t("OutboundLink")],1),e._v(" 诞生了，扩展性更强，采用流式处理效率更高。")]),e._v(" "),t("p",[e._v("依托 AMD 模块化编程，SPA(Single-page application) 的实现方式更为简单清晰，一个网页不再是传统的类似 word 文档的页面，而是一个完整的应用程序。SPA 应用有一个总的入口页面，我们通常把它命名为 index.html、app.html、main.html，这个 html 的 "),t("code",[e._v("<body>")]),e._v(" 一般是空的，或者只有总的布局（layout），比如下图：")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/7072486-e4d8616ab5f42665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image"}})]),e._v(" "),t("p",[e._v("布局会把 header、nav、footer 的内容填上，但 main 区域是个空的容器。这个作为入口的 html 最主要的工作是加载启动 SPA 的 js 文件，然后由 js 驱动，根据当前浏览器地址进行路由分发，加载对应的 AMD 模块，然后该 AMD 模块执行，渲染对应的 html 到页面指定的容器内（比如图中的 main）。在点击链接等交互时，页面不会跳转，而是由 js 路由加载对应的 AMD 模块，然后该 AMD 模块渲染对应的 html 到容器内。")]),e._v(" "),t("p",[e._v("虽然 AMD 模块让 SPA 更容易地实现，但小问题还是很多的：")]),e._v(" "),t("ul",[t("li",[e._v("不是所有的第三方库都是 AMD 规范的，这时候要配置 "),t("code",[e._v("shim")]),e._v("，很麻烦。")]),e._v(" "),t("li",[e._v("虽然 RequireJS 支持通过插件把 html 作为依赖加载，但 html 里面的 "),t("code",[e._v("<img>")]),e._v(" 的路径是个问题，需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变，或者使用 html 模板语言把 "),t("code",[e._v("src")]),e._v(" 写成变量，在运行时生成。")]),e._v(" "),t("li",[e._v("不支持动态加载 css，变通的方法是把所有的 css 文件合并压缩成一个文件，在入口的 html 页面一次性加载。")]),e._v(" "),t("li",[e._v("SPA 项目越做越大，一个应用打包后的 js 文件到了几 MB 的大小。虽然 "),t("a",{attrs:{href:"http://requirejs.org/docs/optimization.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("r.js"),t("OutboundLink")],1),e._v(" 支持分模块打包，但配置很麻烦，因为模块之间会互相依赖，在配置的时候需要 exclude 那些通用的依赖项，而依赖项要在文件里一个个检查。")]),e._v(" "),t("li",[e._v("所有的第三方库都要自己一个个的下载，解压，放到某个目录下，更别提更新有多麻烦了。虽然可以用 "),t("a",{attrs:{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm"),t("OutboundLink")],1),e._v(" 包管理工具，但 npm 的包都是 CommonJS 规范的，给后端 Node.js 用的，只有部分支持 AMD 规范，而且在 npm 3 之前，这些包有依赖项的话也是不能用的。后来有个 "),t("a",{attrs:{href:"https://bower.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("bower"),t("OutboundLink")],1),e._v(" 包管理工具是专门的 web 前端仓库，这里的包一般都支持 AMD 规范。")]),e._v(" "),t("li",[e._v("AMD 规范定义和引用模块的语法太麻烦，上面介绍的 AMD 语法仅是最简单通用的语法，API 文档里面还有很多变异的写法，特别是当发生循环引用的时候（a 依赖 b，b 依赖 a），需要使用其他的 "),t("a",{attrs:{href:"http://requirejs.org/docs/api.html#circular",target:"_blank",rel:"noopener noreferrer"}},[e._v("语法"),t("OutboundLink")],1),e._v(" 解决这个问题。而且 npm 上很多前后端通用的库都是 CommonJS 的语法。后来很多人又开始尝试使用 ES6 模块规范，如何引用 ES6 模块又是一个大问题。")]),e._v(" "),t("li",[e._v("项目的文件结构不合理，因为 grunt/gulp 是按照文件格式批量处理的，所以一般会把 js、html、css、图片分别放在不同的目录下，所以同一个模块的文件会散落在不同的目录下，开发的时候找文件是个麻烦的事情。code review 时想知道一个文件是哪个模块的也很麻烦，解决办法比如又要在 imgs 目录下建立按模块命名的文件夹，里面再放图片。")])]),e._v(" "),t("p",[e._v("到了这里，我们的主角 webpack 登场了（2012 年）（此处应有掌声）。")]),e._v(" "),t("p",[e._v("和 webpack 差不多同期登场的还有 "),t("a",{attrs:{href:"http://browserify.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Browserify"),t("OutboundLink")],1),e._v("。这里简单介绍一下 Browserify。Browserify 的目的是让前端也能用 CommonJS 的语法 "),t("code",[e._v("require('module')")]),e._v(" 来加载 js。它会从入口 js 文件开始，把所有的 "),t("code",[e._v("require()")]),e._v(" 调用的文件打包合并到一个文件，这样就解决了异步加载的问题。那么 Browserify 有什么不足之处导致我不推荐使用它呢? 主要原因有下面几点：")]),e._v(" "),t("ul",[t("li",[e._v("最主要的一点，Browserify 不支持把代码打包成多个文件，在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。")]),e._v(" "),t("li",[e._v("Browserify 对其他非 js 文件的加载不够完善，因为它主要解决的是 "),t("code",[e._v("require()")]),e._v(" js 模块的问题，其他文件不是它关心的部分。比如 html 文件里的 img 标签，它只能转成 "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Data_URI_scheme",target:"_blank",rel:"noopener noreferrer"}},[e._v("Data URI"),t("OutboundLink")],1),e._v(" 的形式，而不能替换为打包后的路径。")]),e._v(" "),t("li",[e._v("因为上面一点 Browserify 对资源文件的加载支持不够完善，导致打包时一般都要配合 gulp 或 grunt 一块使用，无谓地增加了打包的难度。")]),e._v(" "),t("li",[e._v("Browserify 只支持 CommonJS 模块规范，不支持 AMD 和 ES6 模块规范，这意味旧的 AMD 模块和将来的 ES6 模块不能使用。")])]),e._v(" "),t("p",[e._v("基于以上几点，Browserify 并不是一个理想的选择。那么 webpack 是否解决了以上的几个问题呢? 废话，不然介绍它干嘛。那么下面章节我们用实战的方式来说明 webpack 是怎么解决上述的问题的。")]),e._v(" "),t("h2",{attrs:{id:"上手先搞一个简单的-spa-应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上手先搞一个简单的-spa-应用"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%B8%8A%E6%89%8B%E5%85%88%E6%90%9E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-spa-%E5%BA%94%E7%94%A8",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("上手先搞一个简单的 SPA 应用")]),e._v(" "),t("p",[e._v("一上来步子太大容易扯到蛋，让我们先弄个最简单的 webpack 配置来热一下身。")]),e._v(" "),t("h3",{attrs:{id:"安装-node-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-node-js"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%AE%89%E8%A3%85-nodejs",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("安装 Node.js")]),e._v(" "),t("p",[e._v("webpack 是基于我大 Node.js 的打包工具，上来第一件事自然是先安装 Node.js 了，"),t("a",{attrs:{href:"https://nodejs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送门 ->"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"初始化一个项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化一个项目"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("初始化一个项目")]),e._v(" "),t("p",[e._v("我们先随便找个地方，建一个文件夹叫 "),t("code",[e._v("simple")]),e._v("， 然后在这里面搭项目。完成品在 "),t("a",{attrs:{href:"https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/simple",target:"_blank",rel:"noopener noreferrer"}},[e._v("examples/simple"),t("OutboundLink")],1),e._v(" 目录，大家搞的时候可以参照一下。我们先看一下目录结构：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── dist                      打包输出目录，只需部署这个目录到生产环境\n├── package.json              项目配置信息\n├── node_modules              npm 安装的依赖包都在这里面\n├── src                       我们的源代码\n│   ├── components            可以复用的模块放在这里面\n│   ├── index.html            入口 html\n│   ├── index.js              入口 js\n│   ├── shared                公共函数库\n│   └── views                 页面放这里\n└── webpack.config.js         webpack 配置文件\n\n")])])]),t("p",[e._v("打开命令行窗口，"),t("code",[e._v("cd")]),e._v(" 到刚才建的 simple 目录。然后执行这个命令初始化项目：")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm init\n")])])]),t("p",[e._v("命令行会要你输入一些配置信息，我们这里一路按回车下去，生成一个默认的项目配置文件 "),t("code",[e._v("package.json")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"给项目加上语法报错和代码规范检查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给项目加上语法报错和代码规范检查"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E7%BB%99%E9%A1%B9%E7%9B%AE%E5%8A%A0%E4%B8%8A%E8%AF%AD%E6%B3%95%E6%8A%A5%E9%94%99%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%9F%A5",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("给项目加上语法报错和代码规范检查")]),e._v(" "),t("p",[e._v("我们安装 "),t("a",{attrs:{href:"http://eslint.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("eslint"),t("OutboundLink")],1),e._v("， 用来检查语法报错，当我们书写 js 时，有错误的地方会出现提示。")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install eslint eslint-config-enough babel-eslint eslint-loader --save-dev\n")])])]),t("p",[t("code",[e._v("npm install")]),e._v(" 可以一条命令同时安装多个包，包之间用空格分隔。包会被安装进 "),t("code",[e._v("node_modules")]),e._v(" 目录中。")]),e._v(" "),t("p",[t("code",[e._v("--save-dev")]),e._v(" 会把安装的包和版本号记录到 "),t("code",[e._v("package.json")]),e._v(" 中的 "),t("code",[e._v("devDependencies")]),e._v(" 对象中，还有一个 "),t("code",[e._v("--save")]),e._v("， 会记录到 "),t("code",[e._v("dependencies")]),e._v(" 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 "),t("code",[e._v("--save-dev")]),e._v(" 存到 "),t("code",[e._v("devDependencies")]),e._v("， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 "),t("code",[e._v("dependencies")]),e._v("， 比如 jQuery 等。那么它们用来干嘛的？")]),e._v(" "),t("p",[e._v("因为有些 npm 包安装是需要编译的，那么导致 windows / mac /linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 "),t("code",[e._v(".gitignore")]),e._v(" 里指定忽略 node_modules 目录和里面的文件，这样其他人从 git 上拉下来的项目是没有 node_modules 目录的，这时我们需要运行")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install\n")])])]),t("p",[e._v("它会读取 "),t("code",[e._v("package.json")]),e._v(" 中的 "),t("code",[e._v("devDependencies")]),e._v(" 和 "),t("code",[e._v("dependencies")]),e._v(" 字段，把记录的包的相应版本下载下来。")]),e._v(" "),t("p",[e._v("这里 "),t("a",{attrs:{href:"https://github.com/fenivana/eslint-config-enough",target:"_blank",rel:"noopener noreferrer"}},[e._v("eslint-config-enough"),t("OutboundLink")],1),e._v(" 是配置文件，它规定了代码规范，要使它生效，我们要在 "),t("code",[e._v("package.json")]),e._v(" 中添加内容：")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "eslintConfig": {\n    "extends": "enough",\n    "env": {\n      "browser": true,\n      "node": true\n    }\n  }\n}\n')])])]),t("p",[e._v("业界最有名的语法规范是 "),t("a",{attrs:{href:"https://github.com/airbnb/javascript",target:"_blank",rel:"noopener noreferrer"}},[e._v("airbnb"),t("OutboundLink")],1),e._v(" 出品的，但它规定的太死板了，比如不允许使用 "),t("code",[e._v("for-of")]),e._v(" 和 "),t("code",[e._v("for-in")]),e._v(" 等。感兴趣的同学可以参照 "),t("a",{attrs:{href:"https://www.npmjs.com/package/eslint-config-airbnb",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v(" 安装使用。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/babel/babel-eslint",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel-eslint"),t("OutboundLink")],1),e._v(" 是 "),t("code",[e._v("eslint-config-enough")]),e._v(" 依赖的语法解析库，替代 eslint 默认的解析库以支持还未标准化的语法。比如 "),t("a",{attrs:{href:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("import()"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/MoOx/eslint-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("eslint-loader"),t("OutboundLink")],1),e._v(" 用于在 webpack 编译的时候检查代码，如果有错误，webpack 会报错。")]),e._v(" "),t("p",[e._v("项目里安装了 eslint 还没用，我们的 IDE 和编辑器也得要装 eslint 插件支持它。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://code.visualstudio.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Visual Studio Code"),t("OutboundLink")],1),e._v(" 需要安装 "),t("a",{attrs:{href:"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint",target:"_blank",rel:"noopener noreferrer"}},[e._v("ESLint 扩展"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://atom.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("atom"),t("OutboundLink")],1),e._v(" 需要安装 "),t("a",{attrs:{href:"https://atom.io/packages/linter",target:"_blank",rel:"noopener noreferrer"}},[e._v("linter"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://atom.io/packages/linter-eslint",target:"_blank",rel:"noopener noreferrer"}},[e._v("linter-eslint"),t("OutboundLink")],1),e._v(" 这两个插件，装好后重启生效。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.jetbrains.com/webstorm/",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebStorm"),t("OutboundLink")],1),e._v(" 需要在设置中打开 eslint 开关：")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/7072486-c0a131357700b656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"写几个页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写几个页面"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%86%99%E5%87%A0%E4%B8%AA%E9%A1%B5%E9%9D%A2",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("写几个页面")]),e._v(" "),t("p",[e._v("我们写一个最简单的 SPA 应用来介绍 SPA 应用的内部工作原理。首先，建立 src/index.html 文件，内容如下：")]),e._v(" "),t("div",{staticClass:"language-text-html-basic extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8">\n  </head>\n\n  <body>\n  </body>\n</html>\n')])])]),t("p",[e._v("它是一个空白页面，注意这里我们不需要自己写 "),t("code",[e._v('<script src="index.js"><\/script>')]),e._v("， 因为打包后的文件名和路径可能会变，所以我们用 webpack 插件帮我们自动加上。")]),e._v(" "),t("p",[e._v("src/index.js:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 引入 router\nimport router from './router'\n\n// 启动 router\nrouter.start()\n")])])]),t("p",[e._v("src/router.js:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 引入页面文件\nimport foo from './views/foo'\nimport bar from './views/bar'\n\nconst routes = {\n  '/foo': foo,\n  '/bar': bar\n}\n\n// Router 类，用来控制页面根据当前 URL 切换\nclass Router {\n  start() {\n    // 点击浏览器后退 / 前进按钮时会触发 window.onpopstate 事件，我们在这时切换到相应页面\n    // https://developer.mozilla.org/en-US/docs/Web/Events/popstate\n    window.addEventListener('popstate', () => {\n      this.load(location.pathname)\n    })\n\n    // 打开页面时加载当前页面\n    this.load(location.pathname)\n  }\n\n  // 前往 path，变更地址栏 URL，并加载相应页面\n  go(path) {\n    // 变更地址栏 URL\n    history.pushState({}, '', path)\n    // 加载页面\n    this.load(path)\n  }\n\n  // 加载 path 路径的页面\n  load(path) {\n    // 首页\n    if (path === '/') path = '/foo'\n    // 创建页面实例\n    const view = new routes[path]()\n    // 调用页面方法，把页面加载到 document.body 中\n    view.mount(document.body)\n  }\n}\n\n// 导出 router 实例\nexport default new Router()\n")])])]),t("p",[e._v("src/views/foo/index.js:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 引入 router\nimport router from '../../router'\n\n// 引入 html 模板，会被作为字符串引入\nimport template from './index.html'\n\n// 引入 css, 会生成 <style> 块插入到 <head> 头中\nimport './style.css'\n\n// 导出类\nexport default class {\n  mount(container) {\n    document.title = 'foo'\n    container.innerHTML = template\n    container.querySelector('.foo__gobar').addEventListener('click', () => {\n      // 调用 router.go 方法加载 /bar 页面\n      router.go('/bar')\n    })\n  }\n}\n")])])]),t("p",[e._v("src/views/bar/index.js:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 引入 router\nimport router from '../../router'\n\n// 引入 html 模板，会被作为字符串引入\nimport template from './index.html'\n\n// 引入 css, 会生成 <style> 块插入到 <head> 头中\nimport './style.css'\n\n// 导出类\nexport default class {\n  mount(container) {\n    document.title = 'bar'\n    container.innerHTML = template\n    container.querySelector('.bar__gofoo').addEventListener('click', () => {\n      // 调用 router.go 方法加载 /foo 页面\n      router.go('/foo')\n    })\n  }\n}\n")])])]),t("p",[e._v("借助 webpack 插件，我们可以 "),t("code",[e._v("import")]),e._v(" html, css 等其他格式的文件，文本类的文件会被储存为变量打包进 js 文件，其他二进制类的文件，比如图片，可以自己配置，小图片作为 "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Data_URI_scheme",target:"_blank",rel:"noopener noreferrer"}},[e._v("Data URI"),t("OutboundLink")],1),e._v(" 打包进 js 文件，大文件打包为单独文件，我们稍后再讲这块。")]),e._v(" "),t("p",[e._v("其他的 src 目录下的文件大家自己浏览，拷贝一份到自己的工作目录，等会打包时会用到。")]),e._v(" "),t("p",[e._v("页面代码这样就差不多搞定了，接下来我们进入 webpack 的安装和配置阶段。现在我们还没有讲 webpack 配置所以页面还无法访问，等会弄好 webpack 配置后再看页面实际效果。")]),e._v(" "),t("h3",{attrs:{id:"安装-webpack-和-babel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装-webpack-和-babel"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%AE%89%E8%A3%85-webpack-%E5%92%8C-babel",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("安装 webpack 和 Babel")]),e._v(" "),t("p",[e._v("我们把 webpack 和它的插件安装到项目：")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install webpack webpack-cli webpack-serve html-webpack-plugin html-loader css-loader style-loader file-loader url-loader --save-dev\n")])])]),t("p",[t("a",{attrs:{href:"https://github.com/webpack/webpack",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack"),t("OutboundLink")],1),e._v(" 即 webpack 核心库。它提供了很多 "),t("a",{attrs:{href:"https://webpack.js.org/api/node/",target:"_blank",rel:"noopener noreferrer"}},[e._v("API"),t("OutboundLink")],1),e._v(", 通过 Node.js 脚本中 "),t("code",[e._v("require('webpack')")]),e._v(" 的方式来使用 webpack。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/webpack/webpack-cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-cli"),t("OutboundLink")],1),e._v(" 是 webpack 的命令行工具。让我们可以不用写打包脚本，只需配置打包配置文件，然后在命令行输入 "),t("code",[e._v("webpack-cli --config webpack.config.js")]),e._v(" 来使用 webpack, 简单很多。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/webpack-contrib/webpack-serve",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-serve"),t("OutboundLink")],1),e._v(" 是 webpack 提供的用来开发调试的服务器，让你可以用 "),t("a",{attrs:{href:"http://127.0.0.1:8080/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://127.0.0.1:8080/"),t("OutboundLink")],1),e._v(" 这样的 url 打开页面来调试，有了它就不用配置 "),t("a",{attrs:{href:"https://nginx.org/en/",target:"_blank",rel:"noopener noreferrer"}},[e._v("nginx"),t("OutboundLink")],1),e._v(" 了，方便很多。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/ampedandwired/html-webpack-plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("html-webpack-plugin"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://github.com/webpack/html-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("html-loader"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://github.com/webpack/css-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("css-loader"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://github.com/webpack/style-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("style-loader"),t("OutboundLink")],1),e._v(" 等看名字就知道是打包 html 文件，css 文件的插件，大家在这里可能会有疑问，"),t("code",[e._v("html-webpack-plugin")]),e._v(" 和 "),t("code",[e._v("html-loader")]),e._v(" 有什么区别，"),t("code",[e._v("css-loader")]),e._v(" 和 "),t("code",[e._v("style-loader")]),e._v(" 有什么区别，我们等会看配置文件的时候再讲。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/webpack/file-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("file-loader"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://github.com/webpack/url-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("url-loader"),t("OutboundLink")],1),e._v(" 是打包二进制文件的插件，具体也在配置文件章节讲解。")]),e._v(" "),t("p",[e._v("接下来，为了能让不支持 ES6 的浏览器 （比如 IE) 也能照常运行，我们需要安装 "),t("a",{attrs:{href:"http://babeljs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel"),t("OutboundLink")],1),e._v(", 它会把我们写的 ES6 源代码转化成 ES5，这样我们源代码写 ES6，打包时生成 ES5。")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install babel-core babel-preset-env babel-loader --save-dev\n")])])]),t("p",[e._v("这里 "),t("code",[e._v("babel-core")]),e._v(" 顾名思义是 babel 的核心编译器。"),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/preset-env/",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel-preset-env"),t("OutboundLink")],1),e._v(" 是一个配置文件，我们可以使用这个配置文件转换 "),t("a",{attrs:{href:"http://exploringjs.com/es6/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES2015"),t("OutboundLink")],1),e._v("/"),t("a",{attrs:{href:"https://leanpub.com/exploring-es2016-es2017/read",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES2016"),t("OutboundLink")],1),e._v("/"),t("a",{attrs:{href:"http://www.2ality.com/2016/02/ecmascript-2017.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES2017"),t("OutboundLink")],1),e._v(" 到 ES5，是的，不只 ES6 哦。babel 还有 "),t("a",{attrs:{href:"http://babeljs.io/docs/plugins/",target:"_blank",rel:"noopener noreferrer"}},[e._v("其他配置文件"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("光安装了 "),t("code",[e._v("babel-preset-env")]),e._v("，在打包时是不会生效的，需要在 "),t("code",[e._v("package.json")]),e._v(" 加入 "),t("code",[e._v("babel")]),e._v(" 配置：")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "babel": {\n    "presets": ["env"]\n  }\n}\n')])])]),t("p",[e._v("打包时 babel 会读取 "),t("code",[e._v("package.json")]),e._v(" 中 "),t("code",[e._v("babel")]),e._v(" 字段的内容，然后执行相应的转换。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/babel/babel-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel-loader"),t("OutboundLink")],1),e._v(" 是 webpack 的插件，我们下面章节再说。")]),e._v(" "),t("h3",{attrs:{id:"配置-webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置-webpack"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E9%85%8D%E7%BD%AE-webpack",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("配置 webpack")]),e._v(" "),t("p",[e._v("包都装好了，接下来总算可以进入正题了。我们来创建 webpack 配置文件 "),t("code",[e._v("webpack.config.js")]),e._v("，注意这个文件是在 node.js 中运行的，因此不支持 ES6 的 "),t("code",[e._v("import")]),e._v(" 语法。我们来看文件内容：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const { resolve } = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst history = require('connect-history-api-fallback')\nconst convert = require('koa-connect')\n\n// 使用 WEBPACK_SERVE 环境变量检测当前是否是在 webpack-server 启动的开发环境中\nconst dev = Boolean(process.env.WEBPACK_SERVE)\n\nmodule.exports = {\n  /*\n  webpack 执行模式\n  development：开发环境，它会在配置文件中插入调试相关的选项，比如 moduleId 使用文件路径方便调试\n  production：生产环境，webpack 会将代码做压缩等优化\n  */\n  mode: dev ? 'development' : 'production',\n\n  /*\n  配置 source map\n  开发模式下使用 cheap-module-eval-source-map, 生成的 source map 能和源码每行对应，方便打断点调试\n  生产模式下使用 hidden-source-map, 生成独立的 source map 文件，并且不在 js 文件中插入 source map 路径，用于在 error report 工具中查看 （比如 Sentry)\n  */\n  devtool: dev ? 'cheap-module-eval-source-map' : 'hidden-source-map',\n\n  // 配置页面入口 js 文件\n  entry: './src/index.js',\n\n  // 配置打包输出相关\n  output: {\n    // 打包输出目录\n    path: resolve(__dirname, 'dist'),\n\n    // 入口 js 的打包输出文件名\n    filename: 'index.js'\n  },\n\n  module: {\n    /*\n    配置各种类型文件的加载器，称之为 loader\n    webpack 当遇到 import ... 时，会调用这里配置的 loader 对引用的文件进行编译\n    */\n    rules: [\n      {\n        /*\n        使用 babel 编译 ES6 / ES7 / ES8 为 ES5 代码\n        使用正则表达式匹配后缀名为 .js 的文件\n        */\n        test: /\\.js$/,\n\n        // 排除 node_modules 目录下的文件，npm 安装的包不需要编译\n        exclude: /node_modules/,\n\n        /*\n        use 指定该文件的 loader, 值可以是字符串或者数组。\n        这里先使用 eslint-loader 处理，返回的结果交给 babel-loader 处理。loader 的处理顺序是从最后一个到第一个。\n        eslint-loader 用来检查代码，如果有错误，编译的时候会报错。\n        babel-loader 用来编译 js 文件。\n        */\n        use: ['babel-loader', 'eslint-loader']\n      },\n\n      {\n        // 匹配 html 文件\n        test: /\\.html$/,\n        /*\n        使用 html-loader, 将 html 内容存为 js 字符串，比如当遇到\n        import htmlString from './template.html';\n        template.html 的文件内容会被转成一个 js 字符串，合并到 js 文件里。\n        */\n        use: 'html-loader'\n      },\n\n      {\n        // 匹配 css 文件\n        test: /\\.css$/,\n\n        /*\n        先使用 css-loader 处理，返回的结果交给 style-loader 处理。\n        css-loader 将 css 内容存为 js 字符串，并且会把 background, @font-face 等引用的图片，\n        字体文件交给指定的 loader 打包，类似上面的 html-loader, 用什么 loader 同样在 loaders 对象中定义，等会下面就会看到。\n        */\n        use: ['style-loader', 'css-loader']\n      },\n\n      {\n        /*\n        匹配各种格式的图片和字体文件\n        上面 html-loader 会把 html 中 <img> 标签的图片解析出来，文件名匹配到这里的 test 的正则表达式，\n        css-loader 引用的图片和字体同样会匹配到这里的 test 条件\n        */\n        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,\n\n        /*\n        使用 url-loader, 它接受一个 limit 参数，单位为字节(byte)\n\n        当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方\n        当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径\n\n        比如 views/foo/index.html 中\n        <img src=\"smallpic.png\">\n        会被编译成\n        <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...\">\n\n        而\n        <img src=\"largepic.png\">\n        会被编译成\n        <img src=\"/f78661bef717cf2cc2c2e5158f196384.png\">\n        */\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  /*\n  配置 webpack 插件\n  plugin 和 loader 的区别是，loader 是在 import 时根据不同的文件名，匹配不同的 loader 对这个文件做处理，\n  而 plugin, 关注的不是文件的格式，而是在编译的各个阶段，会触发不同的事件，让你可以干预每个编译阶段。\n  */\n  plugins: [\n    /*\n    html-webpack-plugin 用来打包入口 html 文件\n    entry 配置的入口是 js 文件，webpack 以 js 文件为入口，遇到 import, 用配置的 loader 加载引入文件\n    但作为浏览器打开的入口 html, 是引用入口 js 的文件，它在整个编译过程的外面，\n    所以，我们需要 html-webpack-plugin 来打包作为入口的 html 文件\n    */\n    new HtmlWebpackPlugin({\n      /*\n      template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译，\n      webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader\n      html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html\n      可以通过 filename 参数指定输出的文件名\n      html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。\n      */\n      template: './src/index.html',\n\n      /*\n      因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none\n      https://github.com/jantimon/html-webpack-plugin/issues/870\n      */\n      chunksSortMode: 'none'\n    })\n  ]\n}\n\n/*\n配置开发时用的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试\n并且带有热更新的功能，打代码时保存一下文件，浏览器会自动刷新。比 nginx 方便很多\n如果是修改 css, 甚至不需要刷新页面，直接生效。这让像弹框这种需要点击交互后才会出来的东西调试起来方便很多。\n\n因为 webpack-cli 无法正确识别 serve 选项，使用 webpack-cli 执行打包时会报错。\n因此我们在这里判断一下，仅当使用 webpack-serve 时插入 serve 选项。\nissue：https://github.com/webpack-contrib/webpack-serve/issues/19\n*/\nif (dev) {\n  module.exports.serve = {\n    // 配置监听端口，默认值 8080\n    port: 8080,\n\n    // add: 用来给服务器的 koa 实例注入 middleware 增加功能\n    add: app => {\n      /*\n      配置 SPA 入口\n\n      SPA 的入口是一个统一的 html 文件，比如\n      http://localhost:8080/foo\n      我们要返回给它\n      http://localhost:8080/index.html\n      这个文件\n      */\n      app.use(convert(history()))\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"走一个"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#走一个"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E8%B5%B0%E4%B8%80%E4%B8%AA",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("走一个")]),e._v(" "),t("p",[e._v("配置 OK 了，接下来我们就运行一下吧。我们先试一下开发环境用的 "),t("code",[e._v("webpack-serve")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("./node_modules/.bin/webpack-serve webpack.config.js\n")])])]),t("p",[e._v("执行时需要指定配置文件。")]),e._v(" "),t("p",[e._v("上面的命令适用于 Mac / Linux 等 * nix 系统，也适用于 Windows 上的 PowerShell 和 bash/zsh 环境（"),t("a",{attrs:{href:"https://docs.microsoft.com/en-us/windows/wsl/install-win10",target:"_blank",rel:"noopener noreferrer"}},[e._v("Windows Subsystem for Linux"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://git-scm.com/downloads",target:"_blank",rel:"noopener noreferrer"}},[e._v("Git Bash"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"http://babun.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babun"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"http://msys2.github.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("MSYS2"),t("OutboundLink")],1),e._v(" 等）。安利一下 Windows 同学使用 "),t("a",{attrs:{href:"https://www.microsoft.com/store/p/ubuntu/9nblggh4msv6",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ubuntu on Windows"),t("OutboundLink")],1),e._v("，可以避免很多跨平台的问题，比如设置环境变量。")]),e._v(" "),t("p",[e._v("如果使用 Windows 的 cmd.exe，请执行：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("node_modules\\.bin\\webpack-serve webpack.config.js\n\n")])])]),t("p",[e._v("npm 会把包的可执行文件安装到 "),t("code",[e._v("./node_modules/.bin/")]),e._v(" 目录下，所以我们要在这个目录下执行命令。")]),e._v(" "),t("p",[e._v("命令执行后，控制台显示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("｢wdm｣: Compiled successfully。\n\n")])])]),t("p",[e._v("这就代表编译成功了，我们可以在浏览器打开 "),t("code",[e._v("http://localhost:8080/")]),e._v(" 看看效果。如果有报错，那可能是什么地方没弄对？请自己仔细检查一下～")]),e._v(" "),t("p",[e._v("我们可以随意更改一下 src 目录下的源代码，保存后，浏览器里的页面应该很快会有相应变化。")]),e._v(" "),t("p",[e._v("要退出编译，按 "),t("code",[e._v("ctrl+c")]),e._v("。")]),e._v(" "),t("p",[e._v("开发环境编译试过之后，我们试试看编译生产环境的代码，命令是：")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("./node_modules/.bin/webpack-cli\n")])])]),t("p",[e._v("不需要指定配置文件，默认读取 webpack.config.js")]),e._v(" "),t("p",[e._v("执行脚本的命令有点麻烦，因此，我们可以利用 npm，把命令写在 "),t("code",[e._v("package.json")]),e._v(" 中：")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "scripts": {\n    "dev": "webpack-serve webpack.config.js",\n    "build": "webpack-cli"\n  }\n}\n')])])]),t("p",[t("code",[e._v("package.json")]),e._v(" 中的 "),t("code",[e._v("scripts")]),e._v(" 对象，可以用来写一些脚本命令，命令不需要前缀目录 "),t("code",[e._v("./node_modules/.bin/")]),e._v("，npm 会自动寻找该目录下的命令。我们可以执行：")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm run dev\n")])])]),t("p",[e._v("来启动开发环境。")]),e._v(" "),t("p",[e._v("执行")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm run build\n")])])]),t("p",[e._v("来打包生产环境的代码。")]),e._v(" "),t("h2",{attrs:{id:"进阶配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进阶配置"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("进阶配置")]),e._v(" "),t("p",[e._v("上面的项目虽然可以跑起来了，但有几个点我们还没有考虑到：")]),e._v(" "),t("ul",[t("li",[e._v("设置静态资源的 url 路径前缀")]),e._v(" "),t("li",[e._v("各个页面分开打包")]),e._v(" "),t("li",[e._v("第三方库和业务代码分开打包")]),e._v(" "),t("li",[e._v("输出的 entry 文件加上 hash")]),e._v(" "),t("li",[e._v("开发环境关闭 performance.hints")]),e._v(" "),t("li",[e._v("配置 favicon")]),e._v(" "),t("li",[e._v("开发环境允许其他电脑访问")]),e._v(" "),t("li",[e._v("打包时自定义部分参数")]),e._v(" "),t("li",[e._v("webpack-serve 处理路径带后缀名的文件的特殊规则")]),e._v(" "),t("li",[e._v("代码中插入环境变量")]),e._v(" "),t("li",[e._v("简化 import 路径")]),e._v(" "),t("li",[e._v("优化 babel 编译后的代码性能")]),e._v(" "),t("li",[e._v("使用 webpack 自带的 ES6 模块处理功能")]),e._v(" "),t("li",[e._v("使用 autoprefixer 自动创建 css 的 vendor prefixes")])]),e._v(" "),t("p",[e._v("那么，让我们在上面的配置的基础上继续完善，下面的代码我们只写出改变的部分。代码在 "),t("a",{attrs:{href:"https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/advanced",target:"_blank",rel:"noopener noreferrer"}},[e._v("examples/advanced"),t("OutboundLink")],1),e._v(" 目录。")]),e._v(" "),t("h3",{attrs:{id:"设置静态资源的-url-路径前缀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置静态资源的-url-路径前缀"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84-url-%E8%B7%AF%E5%BE%84%E5%89%8D%E7%BC%80",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("设置静态资源的 url 路径前缀")]),e._v(" "),t("p",[e._v("现在我们的资源文件的 url 直接在根目录，比如 "),t("code",[e._v("http://127.0.0.1:8080/index.js")]),e._v("， 这样做缓存控制和 CDN 不是很方便，因此我们给资源文件的 url 加一个前缀，比如 "),t("code",[e._v("http://127.0.0.1:8080/assets/index.js")]),e._v(". 我们来修改一下 webpack 配置：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  output: {\n    publicPath: '/assets/'\n  }\n}\n")])])]),t("p",[t("code",[e._v("webpack-serve")]),e._v(" 也需要修改：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (dev) {\n  module.exports.serve = {\n    port: 8080,\n    host: '0.0.0.0',\n    dev: {\n      /*\n      指定 webpack-dev-middleware 的 publicpath\n      一般情况下与 output.publicPath 保持一致（除非 output.publicPath 使用的是相对路径）\n      https://github.com/webpack/webpack-dev-middleware#publicpath\n      */\n      publicPath: '/assets/'\n    },\n    add: app => {\n      app.use(convert(history({\n        index: '/assets/' // index.html 文件在 /assets/ 路径下\n      })))\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"各个页面分开打包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#各个页面分开打包"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%90%84%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%88%86%E5%BC%80%E6%89%93%E5%8C%85",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("各个页面分开打包")]),e._v(" "),t("p",[e._v("这样浏览器只需加载当前页面所需的代码。")]),e._v(" "),t("p",[e._v("webpack 可以使用异步加载文件的方式引用模块，我们使用 "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",target:"_blank",rel:"noopener noreferrer"}},[e._v("async"),t("OutboundLink")],1),e._v("/ "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await",target:"_blank",rel:"noopener noreferrer"}},[e._v("await"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic import"),t("OutboundLink")],1),e._v(" 来实现：")]),e._v(" "),t("p",[e._v("src/router.js:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 将 async/await 转换成 ES5 代码后需要这个运行时库来支持\nimport 'regenerator-runtime/runtime'\n\nconst routes = {\n  // import() 返回 promise\n  '/foo': () => import('./views/foo'),\n  '/bar.do': () => import('./views/bar.do')\n}\n\nclass Router {\n  // ...\n\n  // 加载 path 路径的页面\n  // 使用 async/await 语法\n  async load(path) {\n    // 首页\n    if (path === '/') path = '/foo'\n\n    // 动态加载页面\n    const View = (await routes[path]()).default\n\n    // 创建页面实例\n    const view = new View()\n\n    // 调用页面方法，把页面加载到 document.body 中\n    view.mount(document.body)\n  }\n}\n")])])]),t("p",[e._v("这样我们就不需要在开头把所有页面文件都 import 进来了。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime",target:"_blank",rel:"noopener noreferrer"}},[e._v("regenerator-runtime"),t("OutboundLink")],1),e._v(" 是 "),t("a",{attrs:{href:"https://github.com/facebook/regenerator",target:"_blank",rel:"noopener noreferrer"}},[e._v("regenerator"),t("OutboundLink")],1),e._v(" 的运行时库。Babel 通过插件 "),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/transform-regenerator",target:"_blank",rel:"noopener noreferrer"}},[e._v("transform-regenerator"),t("OutboundLink")],1),e._v(" 使用 "),t("code",[e._v("regenerator")]),e._v(" 将 "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*",target:"_blank",rel:"noopener noreferrer"}},[e._v("generator"),t("OutboundLink")],1),e._v("函数和 async/await 语法转换成 ES5 语法后，需要运行时库才能正确执行。")]),e._v(" "),t("p",[e._v("另外因为 "),t("code",[e._v("import()")]),e._v(" 还没有正式进入标准，需要使用 "),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/syntax-dynamic-import/",target:"_blank",rel:"noopener noreferrer"}},[e._v("syntax-dynamic-import"),t("OutboundLink")],1),e._v(" 来解析此语法。 我们可以安装 "),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/preset-stage-2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel-preset-stage-2"),t("OutboundLink")],1),e._v("，它包含了 "),t("code",[e._v("import()")]),e._v(" 和其他 stage 2 的语法支持。")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install regenerator-runtime babel-preset-stage-2 --save-dev\n")])])]),t("p",[t("code",[e._v("package.json")]),e._v(" 改一下：")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "babel": {\n    "presets": [\n      "env",\n      "stage-2"\n    ]\n  }\n}\n')])])]),t("p",[e._v("然后修改 webpack 配置：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  output: {\n    /*\n    代码中引用的文件（js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。\n    每个 chunk 包含多个 modules。无论是否是 js，webpack 都将引入的文件视为一个 module。\n    chunkFilename 用来配置这个 chunk 输出的文件名。\n\n    [chunkhash]：这个 chunk 的 hash 值，文件发生变化时该值也会变。使用 [chunkhash] 作为文件名可以防止浏览器读取旧的缓存文件。\n\n    还有一个占位符 [id]，编译时每个 chunk 会有一个id。\n    我们在这里不使用它，因为这个 id 是个递增的数字，增加或减少一个chunk，都可能导致其他 chunk 的 id 发生改变，导致缓存失效。\n    */\n    chunkFilename: '[chunkhash].js',\n  }\n}\n")])])]),t("h3",{attrs:{id:"第三方库和业务代码分开打包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三方库和业务代码分开打包"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%92%8C%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E5%BC%80%E6%89%93%E5%8C%85",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("第三方库和业务代码分开打包")]),e._v(" "),t("p",[e._v("这样更新业务代码时可以借助浏览器缓存，用户不需要重新下载没有发生变化的第三方库。 Webpack 4 最大的改进便是自动拆分 chunk, 如果同时满足下列条件，chunk 就会被拆分：")]),e._v(" "),t("ul",[t("li",[e._v("新的 chunk 能被复用，或者模块是来自 node_modules 目录")]),e._v(" "),t("li",[e._v("新的 chunk 大于 30Kb(min+gz 压缩前）")]),e._v(" "),t("li",[e._v("按需加载 chunk 的并发请求数量小于等于 5 个")]),e._v(" "),t("li",[e._v("页面初始加载时的并发请求数量小于等于 3 个")])]),e._v(" "),t("p",[e._v("一般情况只需配置这几个参数即可：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  plugins: [\n    // ...\n\n    /*\n    使用文件路径的 hash 作为 moduleId。\n    虽然我们使用 [chunkhash] 作为 chunk 的输出名，但仍然不够。\n    因为 chunk 内部的每个 module 都有一个 id，webpack 默认使用递增的数字作为 moduleId。\n    如果引入了一个新文件或删掉一个文件，可能会导致其他文件的 moduleId 也发生改变，\n    那么受影响的 module 所在的 chunk 的 [chunkhash] 就会发生改变，导致缓存失效。\n    因此使用文件路径的 hash 作为 moduleId 来避免这个问题。\n    */\n    new webpack.HashedModuleIdsPlugin()\n  ],\n\n  optimization: {\n    /*\n    上面提到 chunkFilename 指定了 chunk 打包输出的名字，那么文件名存在哪里了呢？\n    它就存在引用它的文件中。这意味着一个 chunk 文件名发生改变，会导致引用这个 chunk 文件也发生改变。\n\n    runtimeChunk 设置为 true, webpack 就会把 chunk 文件名全部存到一个单独的 chunk 中，\n    这样更新一个文件只会影响到它所在的 chunk 和 runtimeChunk，避免了引用这个 chunk 的文件也发生改变。\n    */\n    runtimeChunk: true,\n\n    splitChunks: {\n      /*\n      默认 entry 的 chunk 不会被拆分\n      因为我们使用了 html-webpack-plugin 来动态插入 <script> 标签，entry 被拆成多个 chunk 也能自动被插入到 html 中，\n      所以我们可以配置成 all, 把 entry chunk 也拆分了\n      */\n      chunks: 'all'\n    }\n  }\n}\n")])])]),t("p",[e._v("webpack 4 支持更多的手动优化，详见： "),t("a",{attrs:{href:"https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("但正如 webpack 文档中所说，默认配置已经足够优化，在没有测试的情况下不要盲目手动优化。")]),e._v(" "),t("h3",{attrs:{id:"输出的-entry-文件加上-hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输出的-entry-文件加上-hash"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E8%BE%93%E5%87%BA%E7%9A%84-entry-%E6%96%87%E4%BB%B6%E5%8A%A0%E4%B8%8A-hash",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("输出的 entry 文件加上 hash")]),e._v(" "),t("p",[e._v("上面我们提到了 "),t("code",[e._v("chunkFilename")]),e._v(" 使用 "),t("code",[e._v("[chunkhash]")]),e._v(" 防止浏览器读取错误缓存，那么 entry 同样需要加上 hash。 但使用 "),t("code",[e._v("webpack-serve")]),e._v(" 启动开发环境时，entry 文件是没有 "),t("code",[e._v("[chunkhash]")]),e._v(" 的，用了会报错。 因此我们只在执行 "),t("code",[e._v("webpack-cli")]),e._v(" 时使用 "),t("code",[e._v("[chunkhash]")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  output: {\n    filename: dev ? '[name].js' : '[chunkhash].js'\n  }\n}\n")])])]),t("p",[e._v("这里我们使用了 "),t("code",[e._v("[name]")]),e._v(" 占位符。解释它之前我们先了解一下 "),t("code",[e._v("entry")]),e._v(" 的完整定义:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  entry: {\n    NAME: [FILE1, FILE2, ...]\n  }\n}\n")])])]),t("p",[e._v("我们可以定义多个 entry 文件，比如你的项目有多个 html 入口文件，每个 html 对应一个或多个 entry 文件。 然后每个 entry 可以定义由多个 module 组成，这些 module 会依次执行。 在 webpack 4 之前，这是很有用的功能，比如之前提到的第三方库和业务代码分开打包，在以前，我们需要这么配置：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  entry {\n    main: './src/index.js',\n    vendor: ['jquery', 'lodash']\n  }\n}\n")])])]),t("p",[e._v("entry 引用文件的规则和 "),t("code",[e._v("import")]),e._v(" 是一样的，会寻找 "),t("code",[e._v("node_modules")]),e._v(" 里的包。然后结合 "),t("code",[e._v("CommonsChunkPlugin")]),e._v(" 把 vendor 定义的 module 从业务代码分离出来打包成一个单独的 chunk。 如果 entry 是一个 module，我们可以不使用数组的形式。")]),e._v(" "),t("p",[e._v("在 simple 项目中，我们配置了 "),t("code",[e._v("entry: './src/index.js'")]),e._v("，这是最简单的形式，转换成完整的写法就是：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  entry: {\n    main: ['./src/index.js']\n  }\n}\n")])])]),t("p",[e._v("webpack 会给这个 entry 指定名字为 "),t("code",[e._v("main")]),e._v("。")]),e._v(" "),t("p",[e._v("看到这应该知道 "),t("code",[e._v("[name]")]),e._v(" 的意思了吧？它就是 entry 的名字。")]),e._v(" "),t("p",[e._v("有人可能注意到官网文档中还有一个 "),t("code",[e._v("[hash]")]),e._v(" 占位符，这个 hash 是整个编译过程产生的一个总的 hash 值，而不是单个文件的 hash 值，项目中任何一个文件的改动，都会造成这个 hash 值的改变。"),t("code",[e._v("[hash]")]),e._v(" 占位符是始终存在的，但我们不希望修改一个文件导致所有输出的文件 hash 都改变，这样就无法利用浏览器缓存了。因此这个 "),t("code",[e._v("[hash]")]),e._v(" 意义不大。")]),e._v(" "),t("h3",{attrs:{id:"开发环境关闭-performance-hints"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发环境关闭-performance-hints"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%85%B3%E9%97%AD-performancehints",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("开发环境关闭 performance.hints")]),e._v(" "),t("p",[e._v("我们注意到运行开发环境是命令行会报一段 warning：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).\nThis can impact web performance.\n\n")])])]),t("p",[e._v("这是说建议每个输出的 js 文件的大小不要超过 250k。但开发环境因为包含了 sourcemap 并且代码未压缩所以一般都会超过这个大小，所以我们可以在开发环境把这个 warning 关闭。")]),e._v(" "),t("p",[e._v("webpack 配置中加入：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  performance: {\n    hints: dev ? false : 'warning'\n  }\n}\n")])])]),t("h3",{attrs:{id:"配置-favicon"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置-favicon"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E9%85%8D%E7%BD%AE-favicon",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("配置 favicon")]),e._v(" "),t("p",[e._v("在 src 目录中放一张 favicon.png，然后 "),t("code",[e._v("src/index.html")]),e._v(" 的 "),t("code",[e._v("<head>")]),e._v(" 中插入：")]),e._v(" "),t("div",{staticClass:"language-text-html-basic extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<link rel="icon" type="image/png" href="favicon.png">\n')])])]),t("p",[e._v("修改 webpack 配置：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  module: {\n    rules: [\n      {\n        test: /\\.html$/,\n        use: [\n          {\n            loader: 'html-loader',\n            options: {\n              /*\n              html-loader 接受 attrs 参数，表示什么标签的什么属性需要调用 webpack 的 loader 进行打包。\n              比如 <img> 标签的 src 属性，webpack 会把 <img> 引用的图片打包，然后 src 的属性值替换为打包后的路径。\n              使用什么 loader 代码，同样是在 module.rules 定义中使用匹配的规则。\n\n              如果 html-loader 不指定 attrs 参数，默认值是 img:src, 意味着会默认打包 <img> 标签的图片。\n              这里我们加上 <link> 标签的 href 属性，用来打包入口 index.html 引入的 favicon.png 文件。\n              */\n              attrs: ['img:src', 'link:href']\n            }\n          }\n        ]\n      },\n\n      {\n        /*\n        匹配 favicon.png\n        上面的 html-loader 会把入口 index.html 引用的 favicon.png 图标文件解析出来进行打包\n        打包规则就按照这里指定的 loader 执行\n        */\n        test: /favicon\\.png$/,\n\n        use: [\n          {\n            // 使用 file-loader\n            loader: 'file-loader',\n            options: {\n              /*\n              name：指定文件输出名\n              [hash] 为源文件的hash值，[ext] 为后缀。\n              */\n              name: '[hash].[ext]'\n            }\n          }\n        ]\n      },\n\n      // 图片文件的加载配置增加一个 exclude 参数\n      {\n        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,\n\n        // 排除 favicon.png, 因为它已经由上面的 loader 处理了。如果不排除掉，它会被这个 loader 再处理一遍\n        exclude: /favicon\\.png$/,\n\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n")])])]),t("p",[e._v("其实 html-webpack-plugin 接受一个 "),t("code",[e._v("favicon")]),e._v(" 参数，可以指定 favicon 文件路径，会自动打包插入到 html 文件中。但它有个 "),t("a",{attrs:{href:"https://github.com/ampedandwired/html-webpack-plugin/issues/364",target:"_blank",rel:"noopener noreferrer"}},[e._v("bug"),t("OutboundLink")],1),e._v("，打包后的文件名路径不带 hash，就算有 hash，它也是 [hash]，而不是 [chunkhash]。导致修改代码也会改变 favicon 打包输出的文件名。issue 中提到的 favicons-webpack-plugin 倒是可以用，但它依赖 PhantomJS, 非常大。")]),e._v(" "),t("h3",{attrs:{id:"开发环境允许其他电脑访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开发环境允许其他电脑访问"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%85%81%E8%AE%B8%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E8%AE%BF%E9%97%AE",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("开发环境允许其他电脑访问")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const internalIp = require('internal-ip')\n\nmodule.exports.serve = {\n  host: '0.0.0.0',\n  hot: {\n    host: {\n      client: internalIp.v4.sync(),\n      server: '0.0.0.0'\n    }\n  },\n\n  // ...\n}\n")])])]),t("h3",{attrs:{id:"打包时自定义部分参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包时自定义部分参数"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E6%89%93%E5%8C%85%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("打包时自定义部分参数")]),e._v(" "),t("p",[e._v("在多人开发时，每个人可能需要有自己的配置，比如说 webpack-serve 监听的端口号，如果写死在 webpack 配置里，而那个端口号在某个同学的电脑上被其他进程占用了，简单粗暴的修改 "),t("code",[e._v("webpack.config.js")]),e._v(" 会导致提交代码后其他同学的端口也被改掉。")]),e._v(" "),t("p",[e._v("还有一点就是开发环境、测试环境、生产环境的部分 webpack 配置是不同的，比如 "),t("code",[e._v("publicPath")]),e._v(" 在生产环境可能要配置一个 CDN 地址。")]),e._v(" "),t("p",[e._v("我们在根目录建立一个文件夹 "),t("code",[e._v("config")]),e._v("，里面创建 3 个配置文件：")]),e._v(" "),t("ul",[t("li",[e._v("default.js: 生产环境")])]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = {\n  publicPath: 'http://cdn.example.com/assets/'\n}\n")])])]),t("ul",[t("li",[e._v("dev.js: 默认开发环境")])]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = {\n  publicPath: '/assets/',\n\n  serve: {\n    port: 8090\n  }\n}\n")])])]),t("ul",[t("li",[e._v("local.js: 个人本地环境，在 dev.js 基础上修改部分参数。")])]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const config = require('./dev')\nconfig.serve.port = 8070\nmodule.exports = config\n")])])]),t("p",[t("code",[e._v("package.json")]),e._v(" 修改 "),t("code",[e._v("scripts")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "scripts": {\n    "local": "npm run webpack-serve --config=local",\n    "dev": "npm run webpack-serve --config=dev",\n    "webpack-serve": "webpack-serve webpack.config.js",\n    "build": "webpack-cli"\n  }\n}\n')])])]),t("p",[e._v("webpack 配置修改：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ...\nconst url = require('url')\n\nconst config = require('./config/' + (process.env.npm_config_config || 'default'))\n\nmodule.exports = {\n  // ...\n\n  output: {\n    // ...\n    publicPath: config.publicPath\n  }\n\n  // ...\n}\n\nif (dev) {\n  module.exports.serve = {\n    host: '0.0.0.0',\n    port: config.serve.port,\n    dev: {\n      publicPath: config.publicPath\n    },\n    add: app => {\n      app.use(convert(history({\n        index: url.parse(config.publicPath).pathname\n      })))\n    }\n  }\n}\n")])])]),t("p",[e._v("这里的关键是 "),t("code",[e._v("npm run")]),e._v(" 传进来的自定义参数可以通过 "),t("code",[e._v("process.env.npm_config_*")]),e._v(" 获得。参数中如果有 "),t("code",[e._v("-")]),e._v(" 会被转成 "),t("code",[e._v("_")]),e._v("。")]),e._v(" "),t("p",[e._v("还有一点，我们不需要把自己个人用的配置文件提交到 git，所以我们在 "),t("code",[e._v(".gitignore")]),e._v(" 中加入：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("config/*\n!config/default.js\n!config/dev.js\n\n")])])]),t("p",[e._v("把 "),t("code",[e._v("config")]),e._v(" 目录排除掉，但是保留生产环境和 dev 默认配置文件。")]),e._v(" "),t("p",[e._v("可能有同学注意到了 "),t("code",[e._v("webpack-cli")]),e._v(" 可以通过 "),t("a",{attrs:{href:"https://webpack.js.org/api/cli/#environment-options",target:"_blank",rel:"noopener noreferrer"}},[e._v("--env"),t("OutboundLink")],1),e._v(" 的方式从命令行传参给脚本，遗憾的是 "),t("code",[e._v("webpack-cli")]),e._v(" "),t("a",{attrs:{href:"https://github.com/webpack-contrib/webpack-serve#webpack-function-configs",target:"_blank",rel:"noopener noreferrer"}},[e._v("不支持"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"webpack-serve-处理带后缀名的文件的特殊规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-serve-处理带后缀名的文件的特殊规则"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#webpack-serve-%E5%A4%84%E7%90%86%E5%B8%A6%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("webpack-serve 处理带后缀名的文件的特殊规则")]),e._v(" "),t("p",[e._v("当处理带后缀名的请求时，比如 "),t("a",{attrs:{href:"http://localhost:8080/bar.do",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://localhost:8080/bar.do"),t("OutboundLink")],1),e._v(" ，"),t("code",[e._v("connect-history-api-fallback")]),e._v(" 会认为它应该是一个实际存在的文件，就算找不到该文件，也不会 fallback 到 index.html，而是返回 404。但在 SPA 应用中这不是我们希望的。")]),e._v(" "),t("p",[e._v("幸好有一个配置选项 "),t("code",[e._v("disableDotRule: true")]),e._v(" 可以禁用这个规则，使带后缀的文件当不存在时也能 fallback 到 index.html")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports.serve = {\n  // ...\n  add: app => {\n    app.use(convert(history({\n      // ...\n      disableDotRule: true,\n      htmlAcceptHeaders: ['text/html', 'application/xhtml+xml'] // 需要配合 disableDotRule 一起使用\n    })))\n  }\n}\n")])])]),t("h3",{attrs:{id:"代码中插入环境变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码中插入环境变量"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8F%92%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("代码中插入环境变量")]),e._v(" "),t("p",[e._v("在业务代码中，有些变量在开发环境和生产环境是不同的，比如域名、后台 API 地址等。还有开发环境可能需要打印调试信息等。")]),e._v(" "),t("p",[e._v("我们可以使用 "),t("a",{attrs:{href:"https://webpack.js.org/plugins/define-plugin/",target:"_blank",rel:"noopener noreferrer"}},[e._v("DefinePlugin"),t("OutboundLink")],1),e._v(" 插件在打包时往代码中插入需要的环境变量。")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ...\nconst pkgInfo = require('./package.json')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.DefinePlugin({\n      DEBUG: dev,\n      VERSION: JSON.stringify(pkgInfo.version),\n      CONFIG: JSON.stringify(config.runtimeConfig)\n    }),\n    // ...\n  ]\n}\n")])])]),t("p",[e._v("DefinePlugin 插件的原理很简单，如果我们在代码中写：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(DEBUG)\n")])])]),t("p",[e._v("它会做类似这样的处理：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'console.log(DEBUG)'.replace('DEBUG', true)\n")])])]),t("p",[e._v("最后生成：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(true)\n")])])]),t("p",[e._v("这里有一点需要注意，像这里的 "),t("code",[e._v("VERSION")]),e._v("， 如果我们不对 "),t("code",[e._v("pkgInfo.version")]),e._v(" 做 "),t("code",[e._v("JSON.stringify()")]),e._v("，")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(VERSION)\n")])])]),t("p",[e._v("然后做替换操作：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'console.log(VERSION)'.replace('VERSION', '1.0.0')\n")])])]),t("p",[e._v("最后生成：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log(1.0.0)\n")])])]),t("p",[e._v("这样语法就错误了。所以，我们需要 "),t("code",[e._v("JSON.stringify(pkgInfo.version)")]),e._v(" 转一下变成 "),t("code",[e._v("'\"1.0.0\"'")]),e._v("，替换的时候才会带引号。")]),e._v(" "),t("p",[e._v("还有一点，webpack 打包压缩的时候，会把代码进行优化，比如：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (DEBUG) {\n  console.log('debug mode')\n} else {\n  console.log('production mode')\n}\n")])])]),t("p",[e._v("会被编译成：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (false) {\n  console.log('debug mode')\n} else {\n  console.log('production mode')\n}\n")])])]),t("p",[e._v("然后压缩优化为：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("console.log('production mode')\n")])])]),t("h3",{attrs:{id:"简化-import-路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简化-import-路径"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E7%AE%80%E5%8C%96-import-%E8%B7%AF%E5%BE%84",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("简化 import 路径")]),e._v(" "),t("p",[e._v("文件 a 引入文件 b 时，b 的路径是相对于 a 文件所在目录的。如果 a 和 b 在不同的目录，藏得又深，写起来就会很麻烦：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import b from '../../../components/b'\n")])])]),t("p",[e._v("为了方便，我们可以定义一个路径别名（alias）：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("resolve: {\n  alias: {\n    '~': resolve(__dirname, 'src')\n  }\n}\n")])])]),t("p",[e._v("这样，我们可以以 "),t("code",[e._v("src")]),e._v(" 目录为基础路径来 "),t("code",[e._v("import")]),e._v(" 文件：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import b from '~/components/b'\n")])])]),t("p",[e._v("html 中的 "),t("code",[e._v("<img>")]),e._v(" 标签没法使用这个别名功能，但 "),t("code",[e._v("html-loader")]),e._v(" 有一个 "),t("code",[e._v("root")]),e._v(" 参数，可以使 "),t("code",[e._v("/")]),e._v(" 开头的文件相对于 "),t("code",[e._v("root")]),e._v(" 目录解析。")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  test: /\\.html$/,\n  use: [\n    {\n      loader: 'html-loader',\n      options: {\n        root: resolve(__dirname, 'src'),\n        attrs: ['img:src', 'link:href']\n      }\n    }\n  ]\n}\n")])])]),t("p",[e._v("那么，"),t("code",[e._v('<img src="/favicon.png">')]),e._v(" 就能顺利指向到 src 目录下的 favicon.png 文件，不需要关心当前文件和目标文件的相对路径。")]),e._v(" "),t("p",[e._v("PS: 在调试 "),t("code",[e._v("<img>")]),e._v(" 标签的时候遇到一个坑，"),t("code",[e._v("html-loader")]),e._v(" 会解析 "),t("code",[e._v("\x3c!-- --\x3e")]),e._v(" 注释中的内容，之前在注释中写的")]),e._v(" "),t("div",{staticClass:"language-text-html-basic extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\x3c!--\n大于 10kb 的图片，图片会被储存到输出目录，src 会被替换为打包后的路径\n<img src="/assets/f78661bef717cf2cc2c2e5158f196384.png">\n--\x3e\n')])])]),t("p",[e._v("之前因为没有加 "),t("code",[e._v("root")]),e._v(" 参数，所以 "),t("code",[e._v("/")]),e._v(" 开头的文件名不会被解析，加了 "),t("code",[e._v("root")]),e._v(" 导致编译时报错，找不到该文件。大家记住这一点。")]),e._v(" "),t("h3",{attrs:{id:"优化-babel-编译后的代码性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化-babel-编译后的代码性能"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%BC%98%E5%8C%96-babel-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("优化 babel 编译后的代码性能")]),e._v(" "),t("p",[e._v("babel 编译后的代码一般会造成性能损失，babel 提供了一个 "),t("a",{attrs:{href:"http://babeljs.io/docs/plugins/preset-env/#optionsloose",target:"_blank",rel:"noopener noreferrer"}},[e._v("loose"),t("OutboundLink")],1),e._v(" 选项，使编译后的代码不需要完全遵循 ES6 规定，简化编译后的代码，提高代码执行效率：")]),e._v(" "),t("p",[e._v("package.json:")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "babel": {\n    "presets": [\n      [\n        "env",\n        {\n          "loose": true\n        }\n      ],\n      "stage-2"\n    ]\n  }\n}\n')])])]),t("p",[e._v("但这么做会有兼容性的风险，可能会导致 ES6 源码理应的执行结果和编译后的 ES5 代码的实际结果并不一致。如果代码没有遇到实际的效率瓶颈，官方 "),t("a",{attrs:{href:"http://www.2ality.com/2015/12/babel6-loose-mode.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("不建议"),t("OutboundLink")],1),e._v(" 使用 "),t("code",[e._v("loose")]),e._v(" 模式。")]),e._v(" "),t("h3",{attrs:{id:"使用-webpack-自带的-es6-模块处理功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-webpack-自带的-es6-模块处理功能"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%BD%BF%E7%94%A8-webpack-%E8%87%AA%E5%B8%A6%E7%9A%84-es6-%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86%E5%8A%9F%E8%83%BD",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("使用 webpack 自带的 ES6 模块处理功能")]),e._v(" "),t("p",[e._v("我们目前的配置，babel 会把 ES6 模块定义转为 CommonJS 定义，但 webpack 自己可以处理 "),t("code",[e._v("import")]),e._v(" 和 "),t("code",[e._v("export")]),e._v("， 而且 webpack 处理 "),t("code",[e._v("import")]),e._v(" 时会做代码优化，把没用到的部分代码删除掉。因此我们通过 babel 提供的 "),t("code",[e._v("modules: false")]),e._v(" 选项把 ES6 模块转为 CommonJS 模块的功能给关闭掉。")]),e._v(" "),t("p",[e._v("package.json:")]),e._v(" "),t("div",{staticClass:"language-source-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "babel": {\n    "presets": [\n      [\n        "env",\n        {\n          "loose": true,\n          "modules": false\n        }\n      ],\n      "stage-2"\n    ]\n  }\n}\n')])])]),t("h3",{attrs:{id:"使用-autoprefixer-自动创建-css-的-vendor-prefixes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-autoprefixer-自动创建-css-的-vendor-prefixes"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%BD%BF%E7%94%A8-autoprefixer-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA-css-%E7%9A%84-vendor-prefixes",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("使用 autoprefixer 自动创建 css 的 vendor prefixes")]),e._v(" "),t("p",[e._v("css 有一个很麻烦的问题就是比较新的 css 属性在各个浏览器里是要加前缀的，我们可以使用 "),t("a",{attrs:{href:"https://github.com/postcss/autoprefixer",target:"_blank",rel:"noopener noreferrer"}},[e._v("autoprefixer"),t("OutboundLink")],1),e._v(" 工具自动创建这些浏览器规则，那么我们的 css 中只需要写：")]),e._v(" "),t("div",{staticClass:"language-source-css extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(":fullscreen a {\n    display: flex\n}\n")])])]),t("p",[e._v("autoprefixer 会编译成：")]),e._v(" "),t("div",{staticClass:"language-source-css extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(":-webkit-full-screen a {\n    display: -webkit-box;\n    display: flex\n}\n:-moz-full-screen a {\n    display: flex\n}\n:-ms-fullscreen a {\n    display: -ms-flexbox;\n    display: flex\n}\n:fullscreen a {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex\n}\n")])])]),t("p",[e._v("首先，我们用 npm 安装它：")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install postcss-loader autoprefixer --save-dev\n")])])]),t("p",[e._v("autoprefixer 是 "),t("a",{attrs:{href:"http://postcss.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("postcss"),t("OutboundLink")],1),e._v(" 的一个插件，所以我们也要安装 postcss 的 webpack "),t("a",{attrs:{href:"https://github.com/postcss/postcss-loader",target:"_blank",rel:"noopener noreferrer"}},[e._v("loader"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("修改一下 webpack 的 css rule：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  test: /\\.css$/,\n  use: ['style-loader', 'css-loader', 'postcss-loader']\n}\n")])])]),t("p",[e._v("然后创建文件 "),t("code",[e._v("postcss.config.js")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = {\n  plugins: [\n    require('autoprefixer')()\n  ]\n}\n")])])]),t("h2",{attrs:{id:"使用-webpack-打包多页面应用（multiple-page-application）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-webpack-打包多页面应用（multiple-page-application）"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E4%BD%BF%E7%94%A8-webpack-%E6%89%93%E5%8C%85%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8multiple-page-application",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("使用 webpack 打包多页面应用（Multiple-Page Application）")]),e._v(" "),t("p",[e._v("多页面网站同样可以用 webpack 来打包，以便使用 npm 包，"),t("code",[e._v("import()")]),e._v("，"),t("code",[e._v("code splitting")]),e._v(" 等好处。")]),e._v(" "),t("p",[e._v("MPA 意味着并没不是一个单一的 html 入口和 js 入口，而是每个页面对应一个 html 和多个 js。那么我们可以把项目结构设计为：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── dist\n├── package.json\n├── node_modules\n├── src\n│   ├── components\n│   ├── shared\n|   ├── favicon.png\n│   └── pages                 页面放这里\n|       ├── foo               编译后生成 http://localhost:8080/foo.html\n|       |    ├── index.html\n|       |    ├── index.js\n|       |    ├── style.css\n|       |    └── pic.png\n|       └── bar                        http://localhost:8080/bar.html\n|           ├── index.html\n|           ├── index.js\n|           ├── style.css\n|           └── baz                    http://localhost:8080/bar/baz.html\n|               ├── index.html\n|               ├── index.js\n|               └── style.css\n└── webpack.config.js\n\n")])])]),t("p",[e._v("这里每个页面的 "),t("code",[e._v("index.html")]),e._v(" 是个完整的从 "),t("code",[e._v("<!DOCTYPE html>")]),e._v(" 开头到 "),t("code",[e._v("</html>")]),e._v(" 结束的页面，这些文件都要用 "),t("code",[e._v("html-webpack-plugin")]),e._v(" 处理。"),t("code",[e._v("index.js")]),e._v(" 是每个页面的业务逻辑，作为每个页面的入口 js 配置到 "),t("code",[e._v("entry")]),e._v(" 中。这里我们需要用 "),t("code",[e._v("glob")]),e._v(" 库来把这些文件都筛选出来批量操作。为了使用 webpack 4 的 "),t("code",[e._v("optimization.splitChunks")]),e._v(" 和 "),t("code",[e._v("optimization.runtimeChunk")]),e._v(" 功能，我写了 "),t("a",{attrs:{href:"https://github.com/fenivana/html-webpack-include-sibling-chunks-plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("html-webpack-include-sibling-chunks-plugin"),t("OutboundLink")],1),e._v(" 插件来配合使用。还要装几个插件把 css 压缩并放到 "),t("code",[e._v("<head>")]),e._v(" 中。")]),e._v(" "),t("div",{staticClass:"language-source-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install glob html-webpack-include-sibling-chunks-plugin uglifyjs-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin --save-dev\n")])])]),t("p",[t("code",[e._v("webpack.config.js")]),e._v(" 修改的地方：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ...\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')\nconst HtmlWebpackIncludeSiblingChunksPlugin = require('html-webpack-include-sibling-chunks-plugin')\nconst glob = require('glob')\n\nconst dev = Boolean(process.env.WEBPACK_SERVE)\nconst config = require('./config/' + (process.env.npm_config_config || 'default'))\n\nconst entries = glob.sync('./src/**/index.js')\nconst entry = {}\nconst htmlPlugins = []\nfor (const path of entries) {\n  const template = path.replace('index.js', 'index.html')\n  const chunkName = path.slice('./src/pages/'.length, -'/index.js'.length)\n  entry[chunkName] = dev ? [path, template] : path\n  htmlPlugins.push(new HtmlWebpackPlugin({\n    template,\n    filename: chunkName + '.html',\n    chunksSortMode: 'none',\n    chunks: [chunkName]\n  }))\n}\n\nmodule.exports = {\n  entry,\n\n  output: {\n    path: resolve(__dirname, 'dist'),\n    // 我们不定义 publicPath，否则访问 html 时需要带上 publicPath 前缀\n    filename: dev ? '[name].js' : '[chunkhash].js',\n    chunkFilename: '[chunkhash].js'\n  },\n\n  optimization: {\n    runtimeChunk: true,\n    splitChunks: {\n      chunks: 'all'\n    },\n    minimizer: dev ? [] : [\n      new UglifyJsPlugin({\n        cache: true,\n        parallel: true,\n        sourceMap: true\n      }),\n      new OptimizeCSSAssetsPlugin()\n    ]\n  },\n\n  module: {\n    rules: [\n      // ...\n\n      {\n        test: /\\.css$/,\n        use: [dev ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']\n      },\n\n      // ...\n    ]\n  },\n\n  plugins: [\n    // ...\n\n    /*\n    这里不使用 [chunkhash]\n    因为从同一个 chunk 抽离出来的 css 共享同一个 [chunkhash]\n    [contenthash] 你可以简单理解为 moduleId + content 生成的 hash\n    因此一个 chunk 中的多个 module 有自己的 [contenthash]\n    */\n    new MiniCssExtractPlugin({\n      filename: '[contenthash].css',\n      chunkFilename: '[contenthash].css'\n    }),\n\n    // 必须放在html-webpack-plugin前面\n    new HtmlWebpackIncludeSiblingChunksPlugin(),\n\n    ...htmlPlugins\n  ],\n\n  // ...\n}\n")])])]),t("p",[t("code",[e._v("entry")]),e._v(" 和 "),t("code",[e._v("htmlPlugins")]),e._v(" 会通过遍历 pages 目录生成，比如：")]),e._v(" "),t("p",[e._v("entry:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  'bar/baz': './src/pages/bar/baz/index.js',\n  bar: './src/pages/bar/index.js',\n  foo: './src/pages/foo/index.js'\n}\n")])])]),t("p",[e._v("在开发环境中，为了能够修改 html 文件后网页能够自动刷新，我们还需要把 html 文件也加入 entry 中，比如：")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n  foo: ['./src/pages/foo/index.js', './src/pages/foo/index.html']\n}\n")])])]),t("p",[e._v("这样，当 foo 页面的 index.js 或 index.html 文件改动时，都会触发浏览器刷新该页面。虽然把 html 加入 entry 很奇怪，但放心，不会导致错误。记得不要在生产环境这么做，不然导致 chunk 文件包含了无用的 html 片段。")]),e._v(" "),t("p",[e._v("htmlPlugins:")]),e._v(" "),t("div",{staticClass:"language-source-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[\n  new HtmlWebpackPlugin({\n    template: './src/pages/bar/baz/index.html',\n    filename: 'bar/baz.html',\n    chunksSortMode: 'none',\n    chunks: ['bar/baz']\n  },\n\n  new HtmlWebpackPlugin({\n    template: './src/pages/bar/index.html',\n    filename: 'bar.html',\n    chunksSortMode: 'none',\n    chunks: ['bar']\n  },\n\n  new HtmlWebpackPlugin({\n    template: './src/pages/foo/index.html',\n    filename: 'foo.html',\n    chunksSortMode: 'none',\n    chunks: ['foo']\n  }\n]\n")])])]),t("p",[e._v("代码在 "),t("a",{attrs:{href:"https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/mpa",target:"_blank",rel:"noopener noreferrer"}},[e._v("examples/mpa"),t("OutboundLink")],1),e._v(" 目录。")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://github.com/wallstreetcn/webpack-and-spa-guide#%E6%80%BB%E7%BB%93",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1),e._v("总结")]),e._v(" "),t("p",[e._v("通过这篇文章，我想大家应该学会了 webpack 的正确打开姿势。虽然我没有提及如何用 webpack 来编译 "),t("a",{attrs:{href:"https://facebook.github.io/react/",target:"_blank",rel:"noopener noreferrer"}},[e._v("React"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"http://vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue.js"),t("OutboundLink")],1),e._v(", 但大家可以想到，无非是安装一些 loader 和 plugin 来处理 "),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/preset-react/",target:"_blank",rel:"noopener noreferrer"}},[e._v("jsx"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"http://vue-loader.vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue"),t("OutboundLink")],1),e._v(" 格式的文件，那时难度就不在于 webpack 了，而是代码架构组织的问题了。具体的大家自己去摸索一下。")]),e._v(" "),t("blockquote",[t("p",[e._v("文章来源：https://github.com/wallstreetcn/webpack-and-spa-guide\n作者：wallstreetcn\n声明：文章著作权归作者所有，如有侵权，请联系小编删除。")])]),e._v(" "),t("p",[e._v("关注公众号“web前端导航”，最新的前端教程和学习资料等你来拿！\n"),t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/7072486-65e75c57ef7286c8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image"}})])])}),[],!1,null,null,null);n.default=r.exports}}]);