---
title: js高程读书笔记（1章-5章）
date: 2018-06-22 22:45:23
tags: ["JavaScript","读书笔记"]
---

## 第一章，JavaScript简介
1.JavaScript包含三个部分，ECMAScript，DOM，BOM。
ECMAScript是JavaScript的核心，包括语法，类型，语句，关键字，保留字，操作符，对象。

２.ECMAScript提供核心语言功能。DOM提供访问和操作网页内容的方法和接口。BOM提供与浏览器交互的方法和接口。

３.DOM包含DOM１、DOM２、DOM３。
  - DOM１由两个模块构成DOM核心和DOM HTML；
  - DOM２引入了DOM视图、DOM事件、DOM样式、DOM遍历和范围；
  - DOM３新增了验证文档的方式，并引入了已统一的方式加载和保存文档的方法。
  
## 第二章，在HTML中使用JavaScript
在html中内嵌代码
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>holle world!</title>
  </head>
  <body>
    <p>放到body的底部</p>
    <script>
      alert("holle world!")
    </script>
  </body>
</html>

```
外部引用文件
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>holle world!</title>
  </head>
  <body>
    <p>放到body的底部</p>
    <script src="xxx.js的路径"><script>
  </body>
</html>
```
## 第三章，基本概念
### 1.  ECMAScript数据类型
1.1 有五种基本的数据类型：Undefined，Null，Boolean，Number，String，还有一种复杂的数据类型：Object。typeof可以确定数据类型。[ES6增加新类型：Symbol]

1.2 使用typeof操作符检测null值时会返回“object”，这是因为从逻辑角度来看null指示一个空对象指针。

1.3 Boolean类型的字面值true和false是区分大小写的。若想让其他类型的值转换为Boolean，可以调用转型函数Boolean()。

1.4 Number。八进制第一位必须是0，然后是八进制数字序列（0~7）。十六进制前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。


```
有三个函数可以把非数值转换为数值：Number(),parseInt(),parseFloat();
```


| |转换八进制|转换十六进制|空字符| 字符串
|-|-|-|-|-|
|Number()|忽略前导0，理解为十进制|转换为相同大小的十进制|转换为0| 不全为数字的字符串会转换为NaN|
|parseInt() |转换为相同大小的十进制(在函数第二位加参数8)|转换为相同大小的十进制(在函数第二位加参数16)|转换为NaN|若遇到的第一个字符是数字字符，会一直解析直到遇到第一个非数字字符为止；若遇到的第一个字符为非数字字符，转化为NaN |
|parseFloat() |忽略前导0，理解为十进制|忽略前导0x，理解为十进制,转化为0|同上|同上 |

1.5 String，字符串一旦创建，它的值就不能改变!!!改变的话也只是销毁之后重新创建。

1.6 将一个值转换为字符串，可以使用toString(),Null和Undefined类型没有这个方法。数值，对象，字符串，布尔值均有这个方法。数值调用toString()方法时，可以加参数2,8,10,16，表示转化为相应进制的字符串。

1.7 Object，Object的每个实例都具有以下的属性和方法。

|属性和方法名|说明|
|-|-|
| hasOwnProperty(propertyName)|用于检查给定属性在当前对象实例（而不是实例的原型中）是否存在。eg：o.hasOwnProperty("name")
|isPrototypeOf(object)|用于检查传入的对象是否是传入对象的原型|
|propertyIsEnumerable(propertyName)|	用于检查给定的属性是否能够使用for-in语句来枚举|

### 2.操作符
2.1 任何操作数与NaN进行关系比较，结果都是false。大写字母的字符编码全部小于小写字母的字符编码。

2.2 相等和不相等（== ,!=）,强制转换再比较；全等和不全等（===,!==）,仅比较而不转换。

2.3 由于ECMAScript中不存在块级作用域，因此循环内部定义的变量可以在外部访问到。

2.4 for-in语句可以用来枚举对象的属性。

2.5 break和continue，一般情况下，break语句会立即退出循环，强制执行循环后面的语句，而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。但是遇到与labe标签配合使用，一般发生在循环嵌套的情况下，break会退出到label标签的位置，而continue只是会退出内部循环，执行外部循环。

2.6 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问参数数组。

2.7 ECMAScript没有重载。
## 第四章 变量，作用域和内存问题

### 1\. 基本类型和引用类型的值

1.1 ECMAScript变量可能包含两种不同类型的值：基本类型值和引用类型值，**基本类型值**指的是一个简单的数据段，五种基本数据类型Undifined,Null,Boolean,String,Number是**按值访问**的,因为可以操作保存在变量中的实际的值。**引用类型**的值是保存在内存中的对象，JS不允许直接访问内存中的位置，所以引用类型的值是按**引用访问**的。只有引用类型值可以动态地添加属性。

1.2 访问变量有按值和按引用两种方式，而**参数只能按值传递**。

1.3 **检测类型**，**typeof**,用于确定一个变量是字符串，数值，布尔值，对象还是Undefined的最佳工具。如果一个变量的值是Null或者是Object，则typeof都会返回“Object”。

1.4 **instanceof**用于确定一个值是哪种引用类型。若使用instanceof操作符检测基本类型值，则该操作符始终会返回false。

> `alert(person instanceof Object);` 
> `alert(person instanceof Array);` 
> `alert(person instanceof RegExp);`

### 2\. 执行环境及作用域

2.1 在Web浏览器中，全局执行环境被认为是window对象。

2.2 在try-catch语句的catch块和with语句可以在作用域链的前端临时增加一个变量对象，会延长作用域链。

2.3 JS没有块级作用域，即在if和for语句中声明的变量，在其语句结束后不会销毁，会依旧存在于循环外部的执行环境中。

### 3\. 垃圾收集

3.1 JS中内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理是：找出不再使用的变量，然后释放其占用的内存。具体到浏览器，一般有两种实现方法：**标记清除**，**引用计数**。

3.2 JS中最常用的垃圾收集机制是标记清除。当变量进入环境时，就将这个变量标记为“进入环境”

3.3 **内存管理**，使用具备垃圾收集机制的语言编写程序，开发人员一般不必担心内存管理的问题。但是分配给Web浏览器的可用内存通常要比分配给桌面应用程序的少。

3.4 优化内存的最佳方式是：让执行中的代码只保存必要的数据。一旦数据不再使用，最好将其值设置为null来释放其引用。但是，解除一个值的引用并不意味着自动回收该值所占用的内存，**解除引用**的真正作用是让其值脱离执行环境，以便垃圾收集器下次运行时将其回收。
## 第五章 引用类型

引用类型与传统面向对象程序设计中的类类似，但实现不同。

### 1\. Object类型

Object是一种基础类型，其他所有类型都从Object继承了基本的行为。

### 2\. Arrary类型

2.1 Array类型的每一项可以保存任何类型的数据。数组的大小是可以动态调整的。

2.2 数组的length属性有个特点——它不是只读的。

2.3 **检验数组**

> 方法一：`value instanceof Array` 
> 方法二：`Array.isArray(value)`

2.4 **转化方法**：toString(),valueOf(),前者返回由数组中的每个值的字符串形式拼接而成的一个已逗号分隔的字符串。而后者还是返回的是一个数组。

2.5 **栈方法**和**队列方法**见[这里](http://blog.csdn.net/didiaidada/article/details/44243419)。

2.6 **重排序方法**：reverse()和sort(),前者只是反转数组。后者只是对字符串进行排序。若想比较大下，还得接受一个比较函数作为参数。

2.7 **操作方法**

2.7.1 concat()方法可以基于当前数组中的所有项创建一个新数组。

```
var  colors = ["red","green"];
var colors2 = colors.concat("yellow",["black","brown"]);
```

2.7.2 slice()可以基于当前数组中的一个或多个创建一个新数组。该函数接受一个或者两个参数，即要返回项的起始和结束位置。该方法返回起始和结束位置之间的项，但是不包括结束位置的项。

2.7.3 splice()的功能很强大，可以实现数组中元素的删除,插入,替换。该方法接收两个或者三个参数，起始项的位置，要删除的个数，待插入的元素。

2.8 **位置方法**：ECMAScript5为数组实例添加两个位置方法：indeOf()和lastIndex(),前者从数组开头开始向后查找，后者从数组的末尾开始向前查找。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。未找到的话返回-1。

2.9 **迭代方法**

| 方法名 | 解释(所有方法均运用于数组的每一项) |
| :-- | :-- |
| `every()` | 若该函数对每一项都返回true，则返回true |
| `filter()` | 返回该函数会返回true的项组成的数组 |
| `forEach()` | 无返回值 |
| `map()` | 返回每次函数调用的结果组成的数组 |
| `some()` | 若该函数对某一项返回true，则返回true |

2.10 **归并方法**：reduce()和reduceRight(),这两个函数接收四个参数：前一个值，当前值，项的索引和数组对象。

### 3\. Data类型

3.1 `var now = new Date();`新创建的对象会自动获取当前的日期和时间。

3.2 如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数。Date.parse()和Date.UTC()可以实现。

3.3 Date.now()返回表示调用这个方法时的日期和时间的毫秒数。

3.4 **日期格式化方法**

| 方法 | 说明 |
| :-- | --- |
| toDateString() | 以特定实现的格式显示星期几，月，日和年 |
| toTimeString() | 以特定于实现的格式显示时，分，秒和时区 |
| toLocaleDateString() | 以特定于地区的格式显示星期几，月，日和年 |
| toLocaleTimeString() | 以特定于地区的格式显示时，分，秒和时区 |

### 4\. RegExp类型

```
var expression = / pattern / flags
```

4.1

| flags | 说明 |
| :-- | --- |
| g | 即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 |
| i | 匹配时忽略模式与字符串的大小写 |
| m | 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 |


* * *

4.2 RegExp对象的主要方法是**exec()**,该方法专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。返回的数组包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。

4.3 RegExp的第二个方法是**text()**,他接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。

### 5.Function类型

5.1 函数实际也是对象，每个函数都是Function类型的实例。**函数是对象，函数名是指针。**

5.2 **JavaScript的函数没有重载**

5.3 JS中即使声明函数的代码在调用它的代码后面，JS也能把函数声明提升到顶部。

5.4 在函数内部，有两个特殊的对象：arguments和this。arguments的主要用途是保存函数的参数，但是它还有一个属性名叫**callee**，该属性是一个指针，指向拥有该arguments对象的函数。**this引用的是函数据以执行的环境对象**

5.5 函数的对象的属性**caller**这个属性保存着调用当前函数的函数的引用。

```
    function outer(){
        inner();
        }
    function inner(){
        alert(inner.caller);//也可以是alert(arguments.callee.caller)
        }
    outer();//会弹出outer()函数的源代码
```

5.6 每个函数都包含两个属性：length和prototype。其中length属性表示函数希望接收的命名参数的个数。**prototype是保存函数所有实例方法（toString(),valueOf()）的真正所在**。

5.7 每个函数都包含两个非继承而来的方法：**apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this的值**，实际上，传递参数并非apply()和call()真正的用武之地，它们真正的强大的地方是能够扩充函数赖以运行的作用域。详细用例请点击[这里](http://blog.csdn.net/didiaidada/article/details/45558793)。

```
window.color = 'red';
var o = { colar: 'blue' };

function sayColor(){
    alert(this.color);
    }

sayColor();                //red
sayColor.call(this);       //red
sayColor.call(window);     //red
sayColor.call(o);          //blue
```

***使用call()或者apply()的最大好处是：对象不需要和方法有任何耦合关系。***

5.8 ECMAScript还定义了一个方法：bind(),这个方法会创建一个函数实例，其this的值会被绑定到传给bind()函数的参数值。

### 6\. 基本包装类型

> 为了便于操作基本类型值，ECMAScript还提供了三个特殊引用类型：Boolean，Number和String。 
> 引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这就意味着我们不能再运行时为基本类型添加属性和方法。

6.1 使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

```
var val = '25';
var val1 = Number(val);
alert(typeof val1);          //number

var val2 = new Number(val);
alert(typeof val2);          //object  val2中保存的是Number的实例。
```

6.2 **字符串大小写转换方法**，toLowerCase(),toLocalLowerCase(),toUpperCase(),toLocalUpperCase();

* * *

2015年8月28号回家，今天9月6号，昨天到学校，刚刚写了好多，但是不小心按了backspace,全删了！！！消失的部分以后有心情再写吧

* * *

6.3 `indexOf()`和`lastIndexOf()`返回待查找字符在字符串中的位置。

6.4 `trim()`方法会创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。

6.5 **字符串模式匹配方法**

| 方法名 | 参数 | 返回值 | 备注 |
| :-- | --- | --- | --- |
| `match()` | 一个，正则表达式或者RegExp对象 | 匹配的结果构成的数组 |  |
| `search()` | 同上 | 返回字符串中第一个匹配项的索引 |  |
| `replace()` | 两个，第一个参数和上面的参数一样（也可以是字符串），第二参数是代替换的字符串（也可以是函数） | 返回替换后的字符串 |  |
| **`split()`** | 两个，第一个参数可以是字符串，也可以是RegExp对象，是指定的分隔符。第二个参数用于指定数组的大小 | 通过字符串内包含的指定的分隔符，将字符串分割个多个子字符串，将结果返回在一个数组中 | 可以想象为将铅笔遮住字符串中所以与第一个参数匹配的字符，剩下没有被遮住的部分分别作为数组的每一项返回（可能包括字符串前后的空格） |
| `localeCompare()` | 一个字符串 | 1（字符串参数在字母表中排在调用函数的字符串前面）；0（相等）；-1 |  |
| `fromCharCode()` | 一个或多个字符编码 | 返回对应的字符或字符串 | --- |

### 7.单体内置对象

7.1 **内置对象**：不必显示地实例化内置对象，因为他们已经实例化了。例如Object，Arrary，String。

7.2 **单体内置对象**：Globle，Math。

7.3 **Globle对象**：从某种意义上作为一个终极的“兜底儿对象”，事实上，没有全局变量和全局对象，所有在全局中定义的属性和方法，都是Globle对象的属性。

> URL编码方法
> 
> 1.  encodeURL()和encodeURLComponent()方法可以对URL进行编码，以便发送给浏览器，有效的URL中不能包含某些字符，例如，空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。
> 2.  两个方法中前者用于整个URL（一般只处理空格），后者用于URL的一段（处理所有非字母数字字符）
> 3.  两个对应的解码分别为decodeURL()和decodeURLComponent()。

> eval()方法
> 
> eval()方法就像一个完整的ECMAScript解析器。

> ECMAScript没有指出如何访问Globle()对象，但web浏览器都是将这个全局对象作为window对象的一部分加以实现。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性。

7.4 **Math()对象**

> Math对象的属性大都是数学计算中可能用到一些特殊值，例如：Math.PI

> min()和max()
> 
> eg: `var max = Math.max(3,14,2,14);`
> 
> eg: `var values = [1,2,3,4,5,6,7,8,9]; var max = Math.max.apply(Math, values); //Math作为第一个参数，从而正确的设置this的值`

> 舍入方法
> 
> ```
>         alert(Math.ceil(25.9));
>         alert(Math.ceil(25.5));
>         alert(Math.ceil(25.1));
>         //以上均输出26
>         alert(Math.floor(25.9));
>         alert(Math.floor(25.5));
>         alert(Math.floor(25.1));
>         //以上均输出25
>         alert(Math.round(25.9));
>         alert(Math.round(25.5));
>         alert(Math.round(25.1));
>         //前两项输出26，最后一项输出25，遵循四舍五入
> ```

> Math.random()方法：返回一个大于0小于1的随机数。
> 
> ```
> function selectFrom(lowValue, upperValue){
>             var choice = upperValue - lowValue + 1;
>             return Math.floor(Math.random()*choice + lowValue);
>         }
> ```
> 
> 以上的这个 selectFrom(lowValue, upperValue)可以生成两个参数之间的任意一个随机整数。也可以用于返回数组中的任意一项。

> 其他方法 
> eg：Math.abs(num) 返回num的绝对值。

内容出处: https://blog.csdn.net/didiaidada/article/details/48007449

因为最近也在读js高程 看了觉得总结的很好 自己也修改补充了一部分。可以没事的时候多看看。